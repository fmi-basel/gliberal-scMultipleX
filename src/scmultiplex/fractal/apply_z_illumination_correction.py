# Copyright (C) 2025 Friedrich Miescher Institute for Biomedical Research

##############################################################################
#                                                                            #
# Author: Nicole Repina              <nicole.repina@fmi.ch>                  #
#                                                                            #
##############################################################################

import logging
from typing import Any

import numpy as np
import zarr
from fractal_tasks_core.channels import get_omero_channel_list
from fractal_tasks_core.pyramids import build_pyramid
from fractal_tasks_core.tasks._zarr_utils import _copy_tables_from_zarr_url
from fractal_tasks_core.utils import _split_well_path_image_path
from pydantic import validate_call

from scmultiplex.fractal.fractal_helper_functions import (
    check_match_zarr_chunking,
    copy_folder_from_zarrurl,
    get_channel_index_from_inputmodel,
    load_channel_image,
    load_image_array,
    load_label_rois,
    replace_origin_by_output,
    update_fractal_well_metadata,
)
from scmultiplex.illumination.apply_correction_functions import (
    load_correction_adata,
    run_apply_correction,
)
from scmultiplex.utils.fractal_utils import (
    InitArgsIllumination,
    ZIlluminationChannelInputModel,
)

logger = logging.getLogger(__name__)


@validate_call
def apply_z_illumination_correction(
    *,
    # Fractal arguments
    zarr_url: str,
    init_args: InitArgsIllumination,
    # Task-specific arguments
    input_channels: list[ZIlluminationChannelInputModel],
    label_name: str = "org",
    roi_table: str = "org_ROI_table",
    overwrite_input: bool = False,
    overwrite_output: bool = False,
    output_group_suffix: str = "zillum",
) -> dict[str, Any]:

    """
    Apply z-illumination correction per object in 3D image.

    Task takes as input user-defined channels and z-illumination correction tables,
    and applies correction to the channel images. The channel of the table is matched to the channel of the
    input image based on wavelength id or label. For multiplexing experiments, the user can specify which round(s) and
    channel(s) the z-illumination correction should be applied to.

    The z-illumination correction is applied per object, as different objects can have different z-illumination
    profiles. The object segmentation image is provided with "label_name" and corresponding "roi_table" task inputs.
    The label IDs of these objects must match the ID's that z-illumination calculation was run on (e.g. by running
    Calculate Object Linking).

    Processing proceeds as follows, with chunk-wise parallelization by Dask:
    (1) The input correction table (anndata) is used to generate a 3D correction array that matches the size and
    chunking of the label image. The correction array values are initialized to 1, and for regions where a segmented
    object exists, 1 is replaced with the value of the z-correction table for the object and z-position. If the
    correction table has been generated by the Calculate Z-Illumination Correction task, values of array are 0 to 1;
    values closer to 0 will have a stronger correction.
    (2) Background (user-specified per input channel) is subtracted from the channel image prior to correction. Task
    assumes that background is not object-dependent.
    (3) The channel image is divided element-wise by the correction array.
    (4) Background is added back.

    Output is the input zarr image array, with channels selected for correction replaced with the corrected version.
    Channels in zarr that were not selected but still present in zarr remain unmodified. The output zarr has data
    type "z_illum_corrected", even if some channels remain uncorrected.

    The user has option to overwrite input (=True), in which case the uncorrected zarr is deleted and replaced with
    the corrected zarr. If False, a new zarr is generated (warning - this causes data duplication) with the
    specified suffix added, output_group_suffix.

    Args:
        zarr_url: Path or url to the individual OME-Zarr image to be processed.
        init_args: Initialization arguments provided by
            `init_select_illumination_round`. It contains the zarr-url to the z-illumination correction round.
        input_channels: list of ZIlluminationChannelInputModel objects, where the user specifies the
            channels for applying correction (with wavelength id or label),
            the corresponding name for the z-correction table,
            and the background for this channel. This setting will be applied to all rounds selected in the init task.
            If different values per round are desired, run separate instances of this task in the workflow.
        label_name: Label name of segmentation (usually based on 2D MIP, converted to 3D) that identifies objects
            in image.
        roi_table: Name of the ROI table that corresponds to label_name.
        overwrite_input: If True overwrites the original, uncorrected image with the output of this task.
        overwrite_output: If task has been run before and the corrected zarr with same name already exists, if set to
            True the previous output is overwritten.
        output_group_suffix: If overwrite_input=False, this suffix is added to the new OME-Zarr image that contains
            the z-illumination corrected images.

    """

    logger.info(f"Running for {zarr_url=}. \n")

    # Always use highest resolution label
    level = 0

    correction_tables_zarr_url = init_args.correction_zarr_url

    ##############
    # Load segmentation image  ###
    ##############

    (
        label_dask,
        label_adata,
        label_idlist,
        label_ngffmeta,
        label_pixmeta,
    ) = load_label_rois(
        zarr_url,
        label_name,
        roi_table,
        level,
    )

    ##############
    # Load zarr, includes all channels  ###
    ##############

    img_array, ngffmeta_raw, xycoars_raw, pixmeta_raw = load_image_array(
        zarr_url, level
    )
    img_group = zarr.open_group(zarr_url, mode="r")  # needed to load metadata later

    full_z_count = img_array.shape[-3]

    # identify which channel id's for user-specified channels to process
    # make dict with key: value as channel_id : ZIlluminationChannelInputModel object
    channels_to_correct = {}
    for channel in input_channels:
        channel_id = get_channel_index_from_inputmodel(zarr_url, channel)
        channels_to_correct[channel_id] = channel

    logger.info(
        f"Identified {len(channels_to_correct)} channel(s) to process out of {img_array.shape[0]} channel(s)"
        f" in input zarr array."
    )

    ##############
    # Initialize saving arguments  ###
    ##############

    well_url, _ = _split_well_path_image_path(zarr_url)
    output_zarr_url = f"{well_url}/{zarr_url.split('/')[-1]}_{output_group_suffix}"
    logger.info(f"Output zarr path: {output_zarr_url}")

    # Create zarr for output

    new_zarr = zarr.create(
        shape=img_array.shape,
        chunks=img_array.chunksize,
        dtype=img_array.dtype,
        store=zarr.storage.FSStore(f"{output_zarr_url}/0"),
        overwrite=overwrite_output,
        dimension_separator="/",
    )

    # Initialize new zarr group and copy over metadata from uncorrected zarr
    output_image_group = zarr.group(output_zarr_url)
    output_image_group.attrs.put(img_group.attrs.asdict())

    # Copy labels, plots, and meshes from origin zarr
    folders_to_copy = ["labels", "plots", "meshes"]

    for folder in folders_to_copy:
        copy_folder_from_zarrurl(zarr_url, output_zarr_url, folder_name=folder)

    ##############
    # Apply z-correction to each input channel  ###
    ##############

    all_channels = get_omero_channel_list(image_zarr_path=zarr_url)
    channel_count = 0
    # Loop over channels, apply z-correction, and save to zarr
    # The channels in zarr that are not specified by user for z-illum correction remain unmodified
    # for channel in input_channels:
    for omero_channel in all_channels:
        channel_count += 1
        channel_id = get_channel_index_from_inputmodel(zarr_url, omero_channel)

        logger.info(
            f"Processing channel id {channel_id} (channel count {channel_count} of {len(all_channels)})."
        )

        # Load channel dask array
        ch_dask, _ = load_channel_image(
            omero_channel,
            img_array,
            zarr_url,
            level,
            roi_table,
            label_adata,
            xycoars_raw,
            pixmeta_raw,
        )

        # Task fails if input arrays do not match
        check_match_zarr_chunking(ch_dask, label_dask)

        # apply correction only to user-selected channels
        if channel_id in channels_to_correct:
            zillum_channel_input_model = channels_to_correct[channel_id]
            # get name of channel
            if zillum_channel_input_model.label is not None:
                channel_name = zillum_channel_input_model.label
            elif zillum_channel_input_model.wavelength_id is not None:
                channel_name = zillum_channel_input_model.wavelength_id
            else:
                raise ValueError("Channel could not be identified.")

            correction_table_name = zillum_channel_input_model.z_correction_table
            background_intensity = zillum_channel_input_model.background_intensity

            logger.info(
                f"Using z-illumination correction table {correction_table_name} for "
                f"channel {channel_name} with channel index {channel_id}."
            )

            # Load z-illumination correction table for this channel and perform checks
            correction_adata = load_correction_adata(
                correction_tables_zarr_url,
                correction_table_name,
                full_z_count,
                label_adata,
            )

            # Apply correction
            ch_dask_to_save = run_apply_correction(
                ch_dask, label_dask, correction_adata, background_intensity
            )

            logger.info(f"Built Dask graph for channel {channel_name}.")

        # for non-selected channels, simply write to zarr without processing
        else:
            logger.info(
                "Channel not selected for correction. Copying channel zarr without processing."
            )
            ch_dask_to_save = ch_dask

        logger.info("Starting dask compute and saving of zarr to disk.")

        # Save channel dask to disk
        # This is the command that triggers dask compute
        ch_dask_to_save[None, ...].to_zarr(
            url=new_zarr,
            region=(
                slice(channel_id, channel_id + 1),
                slice(None),
                slice(None),
                slice(None),
            ),
            overwrite=True,
            dimension_separator="/",
            return_stored=False,
            compute=True,
        )

        logger.info(f"Finished saving channel {channel_id} to disk.")

    ##############
    # Build pyramid and clean up zarr metadata ###
    ##############

    build_pyramid(
        zarrurl=output_zarr_url,
        overwrite=True,
        num_levels=ngffmeta_raw.num_levels,
        coarsening_xy=xycoars_raw,
        chunksize=img_array.chunksize,
        aggregation_function=np.mean,
    )

    # Copy tables from origin zarr
    # This Fractal function might not check if tables not in origin exist in zillum zarr, in case
    # when downstream processing of the zillum zarr was already performed?
    _copy_tables_from_zarr_url(zarr_url, output_zarr_url)

    if overwrite_input:
        logger.info("Replacing input zarr with the z-illumination corrected zarr.")
        replace_origin_by_output(zarr_url, output_zarr_url)
        image_list_updates = {}
    else:
        logger.info("Updating well metadata and Fractal image list.")
        # Keep z-illumination corrected zarr separate from input zarr
        # In this case, update well metadata and Fractal image list
        image_list_updates = update_fractal_well_metadata(zarr_url, output_zarr_url)

    logger.info("End apply_z_illumination_correction task.")

    return image_list_updates


if __name__ == "__main__":
    from fractal_tasks_core.tasks._utils import run_fractal_task

    run_fractal_task(
        task_function=apply_z_illumination_correction,
        logger_name=logger.name,
    )
