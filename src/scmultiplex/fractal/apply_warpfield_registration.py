# Copyright 2025 (C) Friedrich Miescher Institute for Biomedical Research and
# University of Zurich
#
# Original authors:
# Nicole Repina <nicole.repina@fmi.ch>
#

"""
Apply warpfield correction from on-disk warpmap to all channels of moving image.
"""

import logging
import os
from pathlib import Path

import numpy as np
from fractal_tasks_core.tasks.io_models import InitArgsRegistration
from ngio import open_ome_zarr_container, open_ome_zarr_plate
from ngio.utils import ngio_logger
from pydantic import validate_call

# Local application imports
from scmultiplex.fractal.fractal_helper_functions import (
    copy_omero_zattrs_from_source_to_target,
    roi_to_pixel_slices,
    save_new_multichannel_image_with_overlap,
)
from scmultiplex.meshing.LabelFusionFunctions import select_label
from scmultiplex.utils.ngio_utils import update_well_zattrs_with_new_image

# Configure logging
ngio_logger.setLevel("ERROR")
logger = logging.getLogger(__name__)


@validate_call
def apply_warpfield_registration(
    *,
    # Fractal arguments
    zarr_url: str,
    init_args: InitArgsRegistration,
    # Task-specific arguments
    roi_table_name: str,
    registration_name: str = "warpfield",
    output_image_suffix: str = "registered",
    mask_output_by_parent: bool = False,
    copy_labels_and_tables: bool = False,
    overwrite: bool = False,
):
    """
    Apply warpfield correction that has been generated with calculate_warpfield_registration task
    to moving image. A new registered image is created. Correction is applied on a per-object basis,
    and to all available channels.

    Args:
        zarr_url: Path or url to the individual OME-Zarr image to be processed.
            (standard argument for Fractal tasks, managed by Fractal server).
        init_args: Intialization arguments provided by
            `_image_based_registration_hcs_init`. They contain the
            reference_zarr_url that is used for registration.
            (standard argument for Fractal tasks, managed by Fractal server).
        roi_table_name: Name of masking ROI table to be used for ROI loading. Typically, this is the
            same roi table used in the calculate_warpfield_registration task to load region pairs between rounds.
            Label ids and shape must correspond to the saved warp maps.
        registration_name: Name of folder that contains warp map .npz files per moving object. It is a
            subfolder of 'registration' folder, generated by the calculate_warpfield_registration task.
        output_image_suffix: This suffix is added to the new OME-Zarr image that contains
            the registered corrected images. Fractal image list updated accordingly.
        mask_output_by_parent: If True, the registered image is masked by parent object label map after
            warpfield correction is applied. This ensures that there are no overlapping regions when writing
            ROIs to disk but may clip object at edges. If False, the new region is merged with the on-disk region by
            taking the element-wise maximum value. In cases of poor registration quality, this may cause
            shadowing (duplicated objects) and edge artifacts between regions.
        copy_labels_and_tables: If True, all labels and tables are copied to the new moving OME-Zarr image from
            the reference zarr.
        overwrite: If True, overwrite existing OME-Zarr image (including all labels and tables).

    """
    try:
        import warpfield
    except ImportError as e:
        raise ImportError(
            "The `apply_warpfield_registration` task requires GPU. "
        ) from e

    logger.info(f"Running 'apply_warpfield_registration' task for {zarr_url=}.")

    # Set OME-Zarr paths
    reference_zarr_url = init_args.reference_zarr_url
    moving_image_name = os.path.basename(zarr_url)
    p = Path(zarr_url)
    plate_url = p.parents[2]  # this is path to .zarr
    row = p.parents[1].name  # e.g 'A'
    column = p.parents[0].name  # e.g '01'
    new_image_name = f"{moving_image_name}_{output_image_suffix}"
    new_moving_zarr_url = os.path.join(plate_url, row, column, new_image_name)

    # Open plate
    plate_ome_zarr = open_ome_zarr_plate(plate_url)
    # Open the ome-zarr image container
    reference_ome_zarr = open_ome_zarr_container(reference_zarr_url)
    moving_ome_zarr = open_ome_zarr_container(zarr_url)
    # Get id of current moving acquisition from plate/well metadata, e.g. "1"
    moving_acquisition_id = plate_ome_zarr.get_well(
        row=row, column=column
    ).get_image_acquisition_id(image_path=moving_image_name)

    # Load ROI tables
    reference_roi_table = reference_ome_zarr.get_table(
        roi_table_name, check_type="generic_roi_table"
    )
    moving_roi_table = moving_ome_zarr.get_table(
        roi_table_name, check_type="generic_roi_table"
    )
    reference_label_name = Path(reference_roi_table._meta.region.path).name
    moving_label_name = Path(moving_roi_table._meta.region.path).name

    # Load images from container
    reference_image = reference_ome_zarr.get_masked_image(
        masking_label_name=reference_label_name
    )
    moving_image = moving_ome_zarr.get_masked_image(
        masking_label_name=moving_label_name
    )
    label_image = reference_ome_zarr.get_masked_label(
        label_name=reference_label_name, masking_label_name=reference_label_name
    )

    # Pixel sizes as list: [z,y,x]
    pixel_size = reference_image.pixel_size
    spacing = np.array([pixel_size.z, pixel_size.y, pixel_size.x])

    # Update well metadata (.zattrs) to add new image, only if does not already exist
    update_well_zattrs_with_new_image(
        zarr_url=zarr_url,
        new_image_name=new_image_name,
        acquisition_id=moving_acquisition_id,
    )

    # Derive the new moving image (e.g. 1_registered) from the reference image (e.g. 0)
    # TODO: select which labels and tables should be copied over
    new_moving_ome_zarr = reference_ome_zarr.derive_image(
        store=new_moving_zarr_url,
        copy_labels=copy_labels_and_tables,
        copy_tables=copy_labels_and_tables,
        overwrite=overwrite,
    )

    # Copy over omero channel metadata from moving image (e.g. 1) to new moving image (e.g. 1_registered)
    copy_omero_zattrs_from_source_to_target(
        source_zarr_url=zarr_url, target_zarr_url=new_moving_zarr_url
    )

    # Apply warpfield correction; load moving ROIs based on reference indices
    for roi in reference_roi_table.rois():
        label_string = roi.name
        label_int = int(label_string)
        logger.info(f"Processing ROI label {label_string} for all channels")
        try:
            moving_np = moving_image.get_roi(
                label=label_int
            )  # load all channels: c,z,y,x
        except KeyError as e:
            logger.warning(
                f"Moving image does not contain matching ROI. Skipping reference ROI {roi}. Error: {e}"
            )
            continue

        # Load the computed warp map from numpy .npz file
        registration_save_path = os.path.join(
            zarr_url, "registration", registration_name
        )
        filename = f"{label_string}.npz"
        warp_map_save_path = os.path.join(registration_save_path, filename)

        npz_data = np.load(warp_map_save_path)

        # Reconstruct the WarpMap
        warp_map = warpfield.register.WarpMap(
            mov_shape=tuple(npz_data["mov_shape"]),
            ref_shape=tuple(npz_data["ref_shape"]),
            block_size=npz_data["block_size"],
            block_stride=npz_data["block_stride"],
            warp_field=npz_data["warp_field"],
        )

        if mask_output_by_parent:
            # Load reference label image
            masking_label = label_image.get_roi(label=label_int)
            masking_label = select_label(masking_label, label_string)  # binarize mask

        # Apply warpfield transformation per channel image
        result = np.empty_like(moving_np)
        for c, moving_channel_np in enumerate(moving_np):

            # Run warpfield transformation
            logger.info(f"Applying warpfield registration for channel {c}.")
            moving_channel_np_registered = warp_map.apply(
                moving_channel_np
            )  # shape z,y,x

            # Optionally mask output by parent after transformation
            if mask_output_by_parent:
                if moving_channel_np_registered.shape != masking_label.shape:
                    raise ValueError(
                        f"Registration output image shape {moving_channel_np_registered.shape} does "
                        f"not match masking label shape {masking_label.shape}"
                    )
                moving_channel_np_registered = (
                    moving_channel_np_registered * masking_label
                )

            result[
                c
            ] = moving_channel_np_registered  # store in the same channel position

        # save ROI to disk using dask _to_zarr, not ngio
        region = roi_to_pixel_slices(roi, spacing)
        save_new_multichannel_image_with_overlap(
            result, new_moving_zarr_url, region, apply_to_all_channels=True
        )

        logger.info(f"Wrote region {label_string} to level-0 zarr image.")

    # Build pyramids
    new_moving_image = new_moving_ome_zarr.get_image()
    new_moving_image.consolidate()

    # Update Fractal image list
    image_list_updates = dict(
        image_list_updates=[dict(zarr_url=new_moving_zarr_url, origin=zarr_url)]
    )

    logger.info(f"End apply_warpfield_registration task for {zarr_url=}")

    return image_list_updates


if __name__ == "__main__":
    from fractal_tasks_core.tasks._utils import run_fractal_task

    run_fractal_task(
        task_function=apply_warpfield_registration,
        logger_name=logger.name,
    )
