{
  "manifest_version": "2",
  "task_list": [
    {
      "name": "scMultiplex Calculate Object Linking",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "2D"
      ],
      "docs_info": "### Purpose\n- Links segmented objects between a reference and an alignment acquisition within a single well of an HCS OME-Zarr dataset.\n- Calculates object shifts using segmentation label maps, aligns objects, and identifies matching labels based on an Intersection over Union (IoU) cutoff threshold.\n- Generates a linking table that maps object labels from the reference acquisition to those in the alignment acquisition.\n\n### Outputs\n- A linking table stored in the alignment acquisition directory.\n- The table includes matched object pairs and their IoU scores.\n\n### Limitations\n- Only works for HCS OME-Zarr datasets where a **single well ROI** is used for linking. Multi-ROI processing (e.g., for FOV ROI tables) is not yet supported.\n- Requires segmentation label maps to be provided for both the reference and alignment acquisitions.\n- Matching is performed using an IoU threshold; objects below the threshold are not linked.\n- Pixel sizes must match between the reference and alignment acquisitions for accurate registration.\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/calculate_object_linking.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Label name that will be used for label-based registration; e.g. `org` from object segmentation."
          },
          "roi_table": {
            "default": "well_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the well ROI table. Input ROI table must have single ROI entry; e.g. `well_ROI_table`"
          },
          "new_linking_table_name": {
            "title": "New Linking Table Name",
            "type": "string",
            "description": "Optional new table name for linked matches, saved in RX alignment round directory. If left None, default is {label_name}_match_table"
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be processed. Choose `0` to process at full resolution."
          },
          "iou_cutoff": {
            "default": 0.2,
            "title": "Iou Cutoff",
            "type": "number",
            "description": "Float in range 0 to 1 to specify intersection over union cutoff. Object pairs that have an iou below this value are filtered out and not stored in linking table."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "label_name"
        ],
        "type": "object",
        "title": "CalculateObjectLinking"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Calculate Linking Consensus",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Calculates a **consensus linking table** across all multiplexing rounds in an HCS OME-Zarr dataset.\n- Aligns object labels from all acquisitions to a reference acquisition, ensuring consistent object identities across rounds.\n- Stores the resulting consensus table in the reference acquisition directory.\n\n### Outputs\n- A **consensus linking table** that maps object labels from all rounds to a single, aligned consensus.\n- The table includes:\n  - Original object labels from each round (e.g., `R0_label`, `R1_label`, ...).\n  - A new consensus label (`consensus_label`) and index (`consensus_index`) for aligned objects.\n\n### Limitations\n- Requires pre-existing linking tables generated by a previous linking task (e.g., `Calculate Object Linking`).\n- Assumes that the input linking tables follow a consistent structure across rounds.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/calculate_linking_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "roi_table": {
            "default": "org_match_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the matching table used to calculate consensus across multiplexing rounds. Typically, this matching table is the output of a linking task, e.g. org_match_table or nuc_match_table. This table must be present in all rounds except for reference round."
          },
          "new_consensus_table_name": {
            "title": "New Consensus Table Name",
            "type": "string",
            "description": "Optional new table name for consensus matches, saved in reference round directory. If left None, default is {roi_table} + \"_consensus\""
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "CalculateLinkingConsensus"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Relabel by Linking Consensus",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Relabels segmentation images and ROI tables in an OME-Zarr dataset based on a pre-calculated **consensus linking table**.\n- Aligns object labels across multiplexing rounds to ensure consistency with the consensus object identities.\n- Outputs new segmentation images and ROI tables with updated labels.\n- Requires a valid **consensus linking table** as input, typically generated by the `Calculate Linking Consensus` task.\n- Non-consensus objects are set to background and excluded from the outputs.\n\n### Outputs\n- A **new segmentation image** where object labels match the consensus labels.\n- A **relabelled ROI table** corresponding to the updated segmentation image, saved with a `_linked` suffix.\n\n### Limitations\n- Only supports **single well ROI tables**; multi-ROI processing (e.g., field of view ROIs) is not yet implemented.\n- Input segmentation images and ROI tables must match in terms of object labels; inconsistencies will cause errors.\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_allrounds_init.py",
      "executable_parallel": "fractal/relabel_by_linking_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 64000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsAllroundsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Label name to be relabeled; e.g. `org` or `nuc`."
          },
          "new_label_name": {
            "title": "New Label Name",
            "type": "string",
            "description": "Optionally new name for relabeled label. If left None, default is {label_name}_linked"
          },
          "consensus_table": {
            "default": "org_match_table_consensus",
            "title": "Consensus Table",
            "type": "string",
            "description": "Name of consensus matching table that specifies consensus matches across rounds, typically stored in reference round zarr."
          },
          "table_to_relabel": {
            "default": "org_ROI_table",
            "title": "Table To Relabel",
            "type": "string",
            "description": "Table name to relabel based on consensus linking. The table rows correspond to specified 'Label name', e.g. 'org_ROI_table' or 'nuc_ROI_table'"
          },
          "discard_labels_not_linked_across_all_rounds": {
            "default": true,
            "title": "Discard Labels Not Linked Across All Rounds",
            "type": "boolean",
            "description": "if True (default), labels that are linked in some but not all rounds are discarded, i.e. only objects linked across all rounds are kept. If False, partially linked labels are kept (e.g. if label is linked between R0 and R1, but missing in R2, the label is still kept)."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "label_name"
        ],
        "type": "object",
        "title": "RelabelByLinkingConsensus"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Calculate Platymatch Registration",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- Calculates point-cloud-based registration between segmentation images using **PlatyMatch**.\n- Works well for **complex 3D registration**.\n- Aligns sub-objects (e.g., nuclei) that belong to parent objects (e.g., organoids) by calculating **affine** and optionally **free-form deformation** transformations.\n- Outputs linking tables of matched sub-objects and optionally saves transformation matrices to disk.\n\n### Outputs\n- A **linking table** that maps sub-objects between reference and alignment rounds using affine and/or free-form deformation (FFD) transformations.\n- Transformation matrices (optional), saved on disk for each object pair.\n\n### Limitations\n- Only supports **single well ROI tables**; multi-ROI processing (e.g., FOV ROIs) is not yet implemented.\n- Requires parent objects to be linked in a prior step using a **consensus linking table**.\n- Assumes consistent pixel sizes between reference and alignment rounds for accurate registration.\n- Relies on sufficient sub-object counts for alignment; regions with fewer than 3 sub-objects are skipped.\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/calculate_platymatch_registration.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "seg_channel": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Seg Channel",
            "description": "Channel that was used for nuclear segmentation; requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`). Assume same across all rounds."
          },
          "label_name_to_register": {
            "default": "nuc",
            "title": "Label Name To Register",
            "type": "string",
            "description": "Label name that will be used for label-based registration, e.g. `nuc`."
          },
          "label_name_obj": {
            "default": "org_linked",
            "title": "Label Name Obj",
            "type": "string",
            "description": "Label name of segmented objects that is parent of label_name_to_register e.g. `org_linked`."
          },
          "roi_table": {
            "default": "org_linked_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. e.g. linked consensus object table 'org_ROI_table_linked'"
          },
          "new_linking_table_name": {
            "title": "New Linking Table Name",
            "type": "string",
            "description": "Optional new table name for linked matches, saved in RX alignment round directory. Suffix \"_affine\" or \"_ffd\" is added for the respective registration. If left None, default is {label_name_to_register} + \"_match_table_affine\" or \"_match_table_ffd\""
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the labels to register. Choose `0` to process at full resolution."
          },
          "save_transformation": {
            "default": true,
            "title": "Save Transformation",
            "type": "boolean",
            "description": "if True, saves the transformation matrix on disk in subfolder 'transformations'"
          },
          "mask_by_parent": {
            "default": true,
            "title": "Mask By Parent",
            "type": "boolean",
            "description": "if True, nuclei are masked by parent object (e.g. organoid) to only select nuclei belonging to parent. Recommended to set to True when iterating over object (e.g. organoid) ROIs."
          },
          "calculate_ffd": {
            "default": true,
            "title": "Calculate Ffd",
            "type": "boolean",
            "description": "if True, calculate free form deformation registration based on affine linking."
          },
          "volume_filter": {
            "default": true,
            "title": "Volume Filter",
            "type": "boolean",
            "description": "if True, performing volume filtering of nuclei to remove objects smaller than specified volume_filter_threshold."
          },
          "volume_filter_threshold": {
            "default": 0.05,
            "title": "Volume Filter Threshold",
            "type": "number",
            "description": "Multiplier that specifies cutoff for volumes below which nuclei are filtered out, float in range [0,1], e.g. 0.05 means that 5% of median of nuclear volume distribution is used as cutoff. Specify this value if volume filtering is desired. Default 0.05."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "seg_channel"
        ],
        "type": "object",
        "title": "CalculatePlatymatchRegistration"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Surface Mesh Multiscale",
      "category": "Image Processing",
      "modality": "HCS",
      "tags": [
        "3D",
        "mesh"
      ],
      "docs_info": "### Purpose\n- Calculates **3D surface meshes** for parent objects (e.g., tissues, organoids) based on 3D child-level segmentation (e.g., nuclei).\n- Optionally applies **multiscale label fusion** to estimate a smooth parent shape by merging child objects.\n- Generates smoothened surface meshes using **VTK algorithms**, with optional mesh decimation for reduced complexity.\n- Outputs 3D meshes in `.stl` or `.vtp` format and a new well label map in the dataset.\n\n### Outputs\n- **Surface meshes** of parent objects, saved as `.stl` (single object) or `.vtp` (multi-object) files in the dataset\u2019s `meshes` folder.\n- A **new label map** containing fused child-level objects, saved in the OME-Zarr dataset (only if multiscale processing is enabled).\n- A **bounding-box ROI table** corresponding to the new label map.\n\n### Limitations\n- Requires pre-segmented child objects and a parent object ROI table.\n- Multiscale processing requires a **parent label** for accurate object grouping and fusion.\n- Label map outputs may have **overlaps clipped**, where higher-label IDs take precedence in dense regions.\n- Mesh quality can vary with complex geometries; manual tuning of smoothing parameters may be needed for optimal results.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/surface_mesh_multiscale.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "default": "nuc",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation for which mesh is calculated. When Multiscale = True, this is the label name of child objects (e.g. nuclei) that will be used for multiscale surface estimation."
          },
          "group_by": {
            "title": "Group By",
            "type": "string",
            "description": "Label name of segmentated objects that are parents of label_name. If None (default), no grouping is applied and meshes are calculated for the input object (label_name). Instead, if a group_by label is specified, the label_name objects will be masked and grouped by this object. For example, when group_by = 'org', the nuclear segmentation is masked by the organoid parent and all nuclei belonging to the parent are loaded as a label image. Thus, when Multiscale = False, the calculated mesh contains multiple child objects. When Multiscale = True, a new labelmap is generated as a result of child fusion to generate the 3D parent (organoid-level) shape."
          },
          "roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table used to iterate over objects and load object regions. If group_by = None, this is the ROI table that corresponds to the label_name objects. If group_by is passed, this is the ROI table for the group_by objects, e.g. org_ROI_table."
          },
          "multiscale": {
            "default": true,
            "title": "Multiscale",
            "type": "boolean",
            "description": "if True, a new labelmap is generated as a result of child fusion to generate the 3D parent (organoid-level) shape. This label output is called {group_by}_from_{label_name}, with corresponding ROI table name {group_by}_ROI_table_from_{label_name}. This label image is optionally saved as a mesh if save_mesh = True. If Multiscale = False, no multiscale label map computation is performed and a smoothened mesh of the input label_name is generated."
          },
          "save_mesh": {
            "default": true,
            "title": "Save Mesh",
            "type": "boolean",
            "description": "if True, calculates and saves mesh on disk in the 'meshes' folder within zarr structure. Meshes saved as '.stl', except for the case of multi-object meshed (e.g. multiple nuclei within a parent organoid) that are saved as '.vtp' to preserve label ID information. Filename corresponds to parent object label id, or to label id in the case when group_by = None."
          },
          "new_mesh_name": {
            "title": "New Mesh Name",
            "type": "string",
            "description": "Optionally new name for new label map (if multiscale) and mesh subfolder (if save_mesh) that is generated. If left None, default is {label_name}."
          },
          "expandby_factor": {
            "default": 0.6,
            "title": "Expandby Factor",
            "type": "number",
            "description": "only used if Multiscale = True. Multiplier that specifies pixels by which to expand each nuclear mask for merging, float in range [0, 1 or higher], e.g. 0.2 means that 20% of mean of nuclear equivalent diameter is used."
          },
          "sigma_factor": {
            "default": 5,
            "title": "Sigma Factor",
            "type": "number",
            "description": "only used if Multiscale = True. Float that specifies sigma (standard deviation, in pixels) for Gaussian kernel used for blurring to smoothen label image prior to edge detection. Higher values correspond to more blurring. Recommended range 5-15."
          },
          "canny_threshold": {
            "default": 0.3,
            "title": "Canny Threshold",
            "type": "number",
            "description": "only used if Multiscale = True. Image values below this threshold are set to 0 after Gaussian blur. float in range [0,1]. Higher values result in tighter fit of mesh to nuclear surface."
          },
          "mask_contour_by_parent": {
            "default": false,
            "title": "Mask Contour By Parent",
            "type": "boolean",
            "description": "if True, the final multiscale edges are masking by 2D parent object mask. Can be used to define cleaner edge borders between touching organoids, but may crop surface mask if higher blurring is desired."
          },
          "fill_holes": {
            "default": false,
            "title": "Fill Holes",
            "type": "boolean",
            "description": "if True, the label image just prior to meshing has holes filled by iterating over slices. Useful for filling lumens in segmentation."
          },
          "filter_by_object_volume": {
            "default": false,
            "title": "Filter By Object Volume",
            "type": "boolean",
            "description": "if True, the label image is filtered by volume. This skips objects with lower volume (number of pixels, calculated after all processing and hole filling, if applied) than the object_volume_filter_threshold."
          },
          "object_volume_filter_threshold": {
            "default": 60000,
            "title": "Object Volume Filter Threshold",
            "type": "integer",
            "description": "Integer threshold for object volume filtering. Number of pixels. E.g. if set to 600, objects with a pixel count less than 600 are skipped. Only used if filter_by_object_volume is True."
          },
          "filter_children_by_volume": {
            "default": false,
            "title": "Filter Children By Volume",
            "type": "boolean",
            "description": "if True, performing volume filtering of nuclei to remove objects smaller than specified volume_filter_threshold."
          },
          "child_volume_filter_threshold": {
            "default": 0.05,
            "title": "Child Volume Filter Threshold",
            "type": "number",
            "description": "Multiplier that specifies cutoff for volumes below which nuclei are filtered out, float in range [0,1], e.g. 0.05 means that 5% of median of nuclear volume distribution is used as cutoff. Specify this value if volume filtering is desired. Default 0.05."
          },
          "polynomial_degree": {
            "default": 30,
            "title": "Polynomial Degree",
            "type": "integer",
            "description": "Mesh smoothing parameter. The number of polynomial degrees during surface mesh smoothing with vtkWindowedSincPolyDataFilter determines the maximum number of smoothing passes. This number corresponds to the degree of the polynomial that is used to approximate the windowed sinc function. Usually 10-20 iteration are sufficient. Higher values have little effect on smoothing. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "passband": {
            "default": 0.01,
            "title": "Passband",
            "type": "number",
            "description": "Mesh smoothing parameter. Float in range [0,2] that specifies the PassBand for the windowed sinc filter in vtkWindowedSincPolyDataFilter during mesh smoothing. Lower passband values produce more smoothing, due to filtering of higher frequencies. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "feature_angle": {
            "default": 160,
            "title": "Feature Angle",
            "type": "integer",
            "description": "Mesh smoothing parameter. Integer in range [0,180] that specifies the feature angle for sharp edge identification used for vtk FeatureEdgeSmoothing. Higher values result in more smoothened edges in mesh. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "target_reduction": {
            "default": 0.98,
            "title": "Target Reduction",
            "type": "number",
            "description": "Mesh decimation parameter. Float in range [0,1]. Target reduction is used during mesh decimation via vtkQuadricDecimation to reduce the number of triangles in a triangle mesh, forming a good approximation to the original geometry. Values closer to 1 indicate larger reduction and smaller mesh file size. Note that target_reduction is expressed as the fraction of the original number of triangles in mesh and so is proportional to original mesh size. Note the actual reduction may be less depending on triangulation and topological constraints. For further details see VTK vtkQuadricDecimation documentation."
          },
          "smoothing_iterations": {
            "default": 1,
            "title": "Smoothing Iterations",
            "type": "integer",
            "description": " Mesh smoothing parameter. The number of iterations that mesh smoothing and decimation is run. If smoothing_iterations > 1, the decimated result is used as input for subsequent smoothing rounds. Recommended to start with 1 iteration and increase if resulting smoothing is insufficient. For each iteration after the first, the passband is reduced and feature_angle is increased incrementally to enhance smoothing. Specifically, the passband is reduced by factor 1/(2^n), and the feature_angle is increased by an increment of (5 * n), where n = iteration round (n=0 is the first iteration). The target_reduction is fixed to 0.1 smoothing_iterations > 1. For example if user inputs (0.01, 160, 0.98) for (passband, feature_angle, target_reduction), the second iteration will use parameters (0.005, 165, 0.1), the third (0.0025, 170, 0.1), etc. Maximum feature_angle is capped at 180. Note that additional iterations usually do not significantly add to processing time as the number of mesh verteces is typically significantly reduced after the first decimation iteration."
          },
          "resample_mesh_to_target_point_count": {
            "default": false,
            "title": "Resample Mesh To Target Point Count",
            "type": "boolean",
            "description": "If True, the mesh is resampled to the target_point_count. All smoothing and decimation is performed as specified above. The smoothened mesh is then upsampled (with Loop Subdivision and Quadric Decimation) or downsampled (with Quadric Decimation), depending on whether the number of points in the smoothened mesh is lower or greater than the target_point_count, respectively. If True, all output meshes will have the same total number of points and triangles per object, though different point densities since object volumes are different. All .stl files also have same size. Note that depending on whether input mesh has an even or odd number of points, resampled output might still have slightly varying point/triangle counts between objects. If False, the original smoothened mesh is returned where the number of points differs between objects (but density per surface area is roughly the same)."
          },
          "target_point_count": {
            "default": 5000,
            "title": "Target Point Count",
            "type": "integer",
            "description": "Integer number of points desired in remeshed object. Note that this is approximate and resampled output might still have slightly varying point/triangle counts between objects (e.g. depending on whether input mesh has an even or odd number of points). Only used if resample_mesh_to_target_point_count is True."
          },
          "overwrite_folder": {
            "default": true,
            "title": "Overwrite Folder",
            "type": "boolean",
            "description": "If True, the output mesh folder, if exists, is cleared. Recommended to set True so that any meshes that already exist in folder but in current run are not processed are removed."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "SurfaceMeshMultiscale"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Segment by Intensity Threshold",
      "category": "Segmentation",
      "modality": "HCS",
      "tags": [
        "Classical segmentation",
        "3D"
      ],
      "docs_info": "### Purpose\n- Performs **full 3D object segmentation** of raw intensity images using intensity thresholding.\n- Combines two intensity channels, applies **Gaussian smoothing** and **Canny edge detection** for refined masks.\n- Filters out debris and neighboring objects by selecting the **largest connected component** within a masked region.\n- Outputs a new 3D segmentation label image and an updated masking ROI table.\n\n### Outputs\n- A **new 3D label image** stored in the dataset, with refined object segmentation.\n- A corresponding **bounding-box ROI table** saved as `{output_label_name}_ROI_table`.\n\n### Limitations\n- Requires pre-segmented 2D MIP-based ROI regions as input for masking.\n- Supports intensity thresholding with either **Otsu's method** or a user-defined threshold.\n- Assumes consistent image resolution and pixel intensities across channels.\n- Regions with extreme intensity variations or overlapping objects may require manual parameter tuning for optimal results.\n",
      "executable_non_parallel": "fractal/init_select_many_rounds.py",
      "executable_parallel": "fractal/segment_by_intensity_threshold.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "select_acquisitions": {
            "items": {
              "type": "integer"
            },
            "title": "Select Acquisitions",
            "type": "array",
            "description": "List of rounds to which correction should be applied, list of integers."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "select_acquisitions"
        ],
        "type": "object",
        "title": "InitSelectManyRounds"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "title": "Init Args",
            "type": "object",
            "description": "Init arguments for Fractal server."
          },
          "label_name": {
            "default": "org",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation (usually based on 2D MIP) that identifies objects in image."
          },
          "new_label_name": {
            "default": "org3d",
            "title": "New Label Name",
            "type": "string",
            "description": "Desired name for new output label. The corresponding ROI table will be saved as {output_label_name}_ROI_table."
          },
          "roi_table": {
            "default": "org_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to label_name. This table is used to iterate over objects and load object regions."
          },
          "channel_1": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Channel 1",
            "description": "Channel of raw image used for thresholding. Requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`)."
          },
          "background_channel_1": {
            "default": 800,
            "title": "Background Channel 1",
            "type": "integer",
            "description": "Pixel intensity value of background to subtract from channel 1 raw image."
          },
          "maximum_channel_1": {
            "title": "Maximum Channel 1",
            "type": "integer",
            "description": "Maximum pixel intensity value that channel 1 image is rescaled to."
          },
          "weight_channel_1": {
            "default": 0.5,
            "title": "Weight Channel 1",
            "type": "number",
            "description": "Float specifying weight of channel 1 image. Channels are combined as (weight_channel_1 * ch1_raw) + (weight_channel_2 * ch2_raw). When both weights are 0.5, channels are averaged. If no second channel is provided, this parameter is ignored."
          },
          "combine_with_channel_2": {
            "default": false,
            "title": "Combine With Channel 2",
            "type": "boolean",
            "description": "if True, a second channel can be added. The Channel 1 and 2 images are combined using weights specified with weight_channel_1 and weight_channel_2, and thresholding is performed using this combined image."
          },
          "channel_2": {
            "allOf": [
              {
                "$ref": "#/$defs/ChannelInputModel"
              }
            ],
            "title": "Channel 2",
            "description": "Channel of second raw image to be combined with channel 1 image. Requires either `wavelength_id` (e.g. `A02_C02`) or `label` (e.g. `BCAT`)."
          },
          "background_channel_2": {
            "title": "Background Channel 2",
            "type": "integer",
            "description": "Pixel intensity value of background to subtract from channel 2 raw image."
          },
          "maximum_channel_2": {
            "title": "Maximum Channel 2",
            "type": "integer",
            "description": "Maximum pixel intensity value that channel 1 image is rescaled to."
          },
          "weight_channel_2": {
            "default": 0.5,
            "title": "Weight Channel 2",
            "type": "number",
            "description": "Float specifying weight of channel 2 image. Channels are combined as (weight_channel_1 * ch1_raw) + (weight_channel_2 * ch2_raw)"
          },
          "otsu_threshold": {
            "default": true,
            "title": "Otsu Threshold",
            "type": "boolean",
            "description": "if True, the threshold for each region is calculated with the Otsu method. This threshold method is more robust to intensity variation between objects compared to intensity_threshold."
          },
          "otsu_weight": {
            "default": 1.0,
            "title": "Otsu Weight",
            "type": "number",
            "description": "Scale calculated Otsu threhsold by this value. Values lower than 1 (e.g. 0.9) reduce Otsu threshold (e.g. by 10 %) to include lower-intensity pixels in thresholding."
          },
          "intensity_threshold": {
            "default": -1,
            "title": "Intensity Threshold",
            "type": "integer",
            "description": "Integer that specifies threshold intensity value to binarize image. Must be supplied if Otsu thresholding is not used. Intensities below this value will be set to 0, intensities above are set to 1. The specified value should correspond to intensity range of raw image (e.g. for 16-bit images, 0-65535). Recommended threshold value is above image background level and below dimmest regions of image, particularly at deeper z-depth."
          },
          "gaussian_sigma_raw_image": {
            "default": 30,
            "title": "Gaussian Sigma Raw Image",
            "type": "number",
            "description": "Float that specifies sigma (standard deviation, in pixels) for 3D Gaussian kernel used for blurring of raw intensity image prior to thresholding and edge detection. Higher values correspond to more blurring that reduce holes in thresholded image. Recommended range 10-40."
          },
          "gaussian_sigma_threshold_image": {
            "default": 20,
            "title": "Gaussian Sigma Threshold Image",
            "type": "number",
            "description": "Float that specifies sigma (standard deviation, in pixels) for 2D Gaussian kernel used for blurring each z-slice of thresholded binary image prior to edge detection. Higher values correspond to more blurring and smoother surface edges. Recommended range 10-30."
          },
          "small_objects_diameter": {
            "default": 30,
            "title": "Small Objects Diameter",
            "type": "number",
            "description": "Float that specifies the approximate diameter, in pixels and at level=0, of debris in the image. This value is used to filter out small objects using skimage.morphology.remove_small_objects."
          },
          "expand_by_pixels": {
            "default": 20,
            "title": "Expand By Pixels",
            "type": "integer",
            "description": "Expand initial threshold mask by this number of pixels and fill holes. Mask is subsequently dilated and returned to original size. This step serves to fill holes in dim regions. Higher values lead to more holes filled, but neighboring objects or debris may become fused."
          },
          "contour_value_outer": {
            "default": 0.8,
            "title": "Contour Value Outer",
            "type": "number",
            "description": "Float in range [0,1]. This is the value used to draw contour line around object. Higher values result in tighter fit of edge mask to intensity image."
          },
          "linear_z_illumination_correction": {
            "default": false,
            "title": "Linear Z Illumination Correction",
            "type": "boolean",
            "description": "Set to True if linear z illumination correction is desired. Iterate over z-slices to apply correction."
          },
          "start_z_slice": {
            "default": 40,
            "title": "Start Z Slice",
            "type": "integer",
            "description": "Z-slice number at which to begin to apply linear correction, e.g. slice 40 if image stack has 100 slices."
          },
          "m_slope": {
            "default": 0.015,
            "title": "M Slope",
            "type": "number",
            "description": "Slope factor of illumination correction. Higher values have more extreme correction. This value sets the multiplier for a given z-slice by formula m_slope * (i - start_z_slice) + 1, where i is the current z-slice in iterator."
          },
          "segment_lumen": {
            "default": false,
            "title": "Segment Lumen",
            "type": "boolean",
            "description": "if True, lumen (assumed to be negative space in object) will also be segmented. In this case, three label maps are output: outer contour (epithelial surface) with holes filled, inner contour (lumen), and the epithelial mask (difference between outer and inner regions)."
          },
          "contour_value_inner": {
            "default": 0.8,
            "title": "Contour Value Inner",
            "type": "number",
            "description": "Float in range [0,1]. This is the value used to draw contour line around lumen of object. Higher values result in tighter fit of edge mask to intensity image."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "channel_1",
          "maximum_channel_1"
        ],
        "type": "object",
        "title": "SegmentByIntensityThreshold"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Spherical Harmonics from Label Image",
      "category": "Measurement",
      "modality": "HCS",
      "tags": [
        "3D"
      ],
      "docs_info": "### Purpose\n- Computes **spherical harmonics** for 3D segmented objects in a label image using the **aics_shparam** library.\n- Calculates and analyzes the **shape features** of objects, including reconstruction error.\n- Outputs spherical harmonic coefficients and optionally saves reconstructed surface meshes.\n\n### Outputs\n- A **feature table** containing spherical harmonic coefficients and reconstruction error (**MSE**) per object.\n- Optionally, the **computed surface mesh** and the **reconstructed mesh** (from harmonics), saved as `.stl` files in a new `meshes` folder.\n\n### Limitations\n- Input label image must contain 3D segmented objects; neighboring objects are removed by masking.\n- The accuracy of spherical harmonics depends on the chosen **maximum degree (`lmax`)** and input label quality.\n- Mesh reconstruction might smooth out fine details in highly complex shapes.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/spherical_harmonics_from_labelimage.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "default": "org_3d",
            "title": "Label Name",
            "type": "string",
            "description": "Label for which spherical harmonics are calculated"
          },
          "roi_table": {
            "default": "org_ROI_table_3d",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. e.g. consensus object table 'org_ROI_table_consensus'"
          },
          "lmax": {
            "default": 2,
            "title": "Lmax",
            "type": "integer",
            "description": "Maximum degree of the spherical harmonics coefficients"
          },
          "save_mesh": {
            "default": true,
            "title": "Save Mesh",
            "type": "boolean",
            "description": "If True, saves the computed surface mesh (with vtkContourFilter in aics_shparam functions) on disk in subfolder 'meshes'. Filename corresponds to object label id"
          },
          "save_reconstructed_mesh": {
            "default": true,
            "title": "Save Reconstructed Mesh",
            "type": "boolean",
            "description": "If true, reconstruct mesh from spherical harmonics and save as stl in meshes zarr directory. Filename corresponds to object label id"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "SphericalHarmonicsFromLabelimage"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Mesh Measurements",
      "category": "Measurement",
      "modality": "HCS",
      "tags": [
        "3D",
        "mesh",
        "morphology"
      ],
      "docs_info": "### Purpose\n- Extracts detailed **shape features** from 3D meshes, including volume, surface area, solidity, concavity, and aspect ratio.\n- Optionally calculates **Gaussian curvature** for mesh surfaces and **spherical harmonics** to decompose mesh geometry.\n- Outputs feature tables, curvature meshes, and optional harmonic-reconstructed meshes.\n\n### Outputs\n1. A **feature table** with extracted mesh measurements, including:\n   - Volume, surface area, aspect ratio, concavity, normalized surface area-to-volume ratio, and more.\n2. Optional **spherical harmonic coefficients** and reconstruction error (MSE), saved as a separate table.\n3. Optional **reconstructed meshes** from spherical harmonics saved as `.stl`.\n4. Optional **Gaussian curvature meshes** saved as `.vtp` files in a new `curvature` folder.\n5. Optional **convex hull** and **bounding box** meshes saved as `.vtp` files.\n\n### Limitations\n- Requires pre-existing **.stl meshes** within the Zarr structure (e.g., generated by the **Surface Mesh Multiscale** task).\n- Mesh files must match the **object labels** specified in the ROI table.\n- Computational cost increases when enabling **Gaussian curvature** or **spherical harmonics** calculations.\n- Mesh quality and accuracy depend on the input segmentation and mesh generation parameters.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/scmultiplex_mesh_measurements.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Initialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "mesh_name": {
            "title": "Mesh Name",
            "type": "string",
            "description": "Mesh folder name for which features are to be extracted. Must contain .stl format meshes whose filename corresponds to label name in ROI table."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to labels of meshed objects, only used for indexing objects"
          },
          "output_table_name": {
            "title": "Output Table Name",
            "type": "string",
            "description": "Name of the output AnnData table to save the measurements in. A table of this name can't exist yet in the OME-Zarr file"
          },
          "save_hulls": {
            "default": true,
            "title": "Save Hulls",
            "type": "boolean",
            "description": "if True, save the calculated convex hull and bounding box as .vtp meshes within meshes/[mesh_name]_convex_hull and meshes/[mesh_name]_bounding_box directories"
          },
          "calculate_curvature": {
            "default": true,
            "title": "Calculate Curvature",
            "type": "boolean",
            "description": "if True, calculate Gaussian curvature at each mesh point and save as .vtp mesh on disk within meshes/[mesh_name]_curvature folder in zarr structure. Filename corresponds to object label id."
          },
          "calculate_harmonics": {
            "default": true,
            "title": "Calculate Harmonics",
            "type": "boolean",
            "description": "if True, calculate spherical harmonics of mesh using aics_shparam"
          },
          "lmax": {
            "default": 2,
            "title": "Lmax",
            "type": "integer",
            "description": "Maximum degree of the spherical harmonics coefficients"
          },
          "translate_to_origin": {
            "default": true,
            "title": "Translate To Origin",
            "type": "boolean",
            "description": "If true, translate centroid of mesh to origin prior to spherical harmonic decomposition. Recommended set to True"
          },
          "save_reconstructed_mesh": {
            "default": true,
            "title": "Save Reconstructed Mesh",
            "type": "boolean",
            "description": "If true, reconstruct mesh from spherical harmonics and save as stl in meshes zarr directory"
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "mesh_name",
          "roi_table",
          "output_table_name"
        ],
        "type": "object",
        "title": "ScmultiplexMeshMeasurements"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Feature Measurements",
      "category": "Measurement",
      "tags": [
        "regionprops",
        "morphology",
        "intensity"
      ],
      "docs_info": "### Purpose\n- **Measures intensity and morphology features** from existing segmentation images in an OME-Zarr dataset.\n- Computes advanced 3D morphology metrics, including surface area, using extended `regionprops` measurements.\n- Supports both intensity-based and morphology-only measurements:\n   - If no input intensity channels are provided, the task calculates morphology features only.\n   - For intensity measurements, channels can be specified individually, allowing flexibility across different image inputs.\n- Enables **measurements within masked objects** (e.g., measuring nuclei properties within organoids) by specifying an `input_ROI_table` that defines parent regions, such as organoid ROIs.\n\n### Limitations\n- Currently tested only on image data in the **CZYX** format.\n- Measurement accuracy and performance may depend on the spacing and resolution of input images.\n- Does not support measurements at lower resolutions (e.g., beyond level 0).\n",
      "executable_parallel": "fractal/scmultiplex_feature_measurements.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_image": {
            "title": "Label Image",
            "type": "string",
            "description": "Name of the label image to use for measurements. Needs to exist in OME-Zarr file"
          },
          "output_table_name": {
            "title": "Output Table Name",
            "type": "string",
            "description": "Name of the output AnnData table to save the measurements in. A table of this name can't exist yet in the OME-Zarr file"
          },
          "input_channels": {
            "additionalProperties": {
              "$ref": "#/$defs/ChannelInputModel"
            },
            "title": "Input Channels",
            "type": "object",
            "description": "Dictionary of channels to measure. Keys are the names that will be added as prefixes to the measurements, values are another dictionary containing either wavelength_id or channel_label information to allow Fractal to find the correct channel (but not both). Example: {\"C01\": {\"wavelength_id\": \"A01_C01\"}. To only measure morphology, provide an empty dict"
          },
          "input_ROI_table": {
            "default": "well_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table to loop over. Needs to exist as a ROI table in the OME-Zarr file. The label that corresponds to this ROI table to used for masking."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Resolution of the intensity image to load for measurements. Only tested for level 0"
          },
          "label_level": {
            "default": 0,
            "title": "Label Level",
            "type": "integer",
            "description": "Resolution of the label image to load for measurements."
          },
          "measure_morphology": {
            "default": true,
            "title": "Measure Morphology",
            "type": "boolean",
            "description": "Set to True to measure morphology features"
          },
          "allow_duplicate_labels": {
            "default": false,
            "title": "Allow Duplicate Labels",
            "type": "boolean",
            "description": "Set to True to allow saving measurement tables with non-unique label values. Can happen when segmentation is run on a different ROI than the measurements (e.g. segment per well, but measure per FOV)"
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_url",
          "label_image",
          "output_table_name"
        ],
        "type": "object",
        "title": "ScmultiplexFeatureMeasurements"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Expand Labels",
      "category": "Image Processing",
      "tags": [
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Expands segmented **labels** in 2D or 3D images **without overlap**.\n- Supports expansion by a fixed pixel distance or dynamically based on **label size**.\n- Optionally masks expanded labels using **parent objects** to prevent spillover.\n- Outputs an expanded label image and preserves non-overlapping object boundaries.\n\n### Outputs\n- A new **expanded label image** saved with an `_expanded` suffix.\n\n### Limitations\n- If masking by parent is enabled, the parent object label image must be provided.\n- Expansion beyond object boundaries may be clipped, depending on the surrounding labels and image dimensions.\n",
      "executable_parallel": "fractal/expand_labels.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed."
          },
          "label_name_to_expand": {
            "title": "Label Name To Expand",
            "type": "string",
            "description": "Label name of segmentation to be expanded."
          },
          "new_label_name": {
            "title": "New Label Name",
            "type": "string",
            "description": "Optionally new name for expanded label. If left None, default is {label_name_to_expand}_expanded"
          },
          "roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table used to iterate over objects and load object regions. If a table of type \"roi_table\" is passed, e.g. well_ROI_table, all objects for each region in the table will be loaded and expanded simultaneously. If a table of type \"masking_roi_table\" is passed, e.g. a segmentation ROI table, the task iterates over these objects and loads only the children (i.e. label_name_to_expand) that belong to the parent object."
          },
          "masking_label_map": {
            "title": "Masking Label Map",
            "type": "string",
            "description": "Label name of segmented objects that are parents of label_name. This input is mandatory if a roi table of type \"masking_roi_table\" is provided. It is the name of the label map that corresponds to the input ROI table. The masking_label_map will be used to mask label_name_to_expand objects, to only select children belonging to given parent."
          },
          "mask_output": {
            "default": true,
            "title": "Mask Output",
            "type": "boolean",
            "description": "If True, expanded label is masked by parent label. Only used if masking_label_map is provided. Recommended to set as True, to avoid overwriting of children labels between neighboring parents. However, it may lead to expanded results to be cropped by parent mask; in this case, the parent mask can first be expanded."
          },
          "expand_by_pixels": {
            "title": "Expand By Pixels",
            "type": "integer",
            "description": "Default expansion parameter. Integer value for pixel distance to expand by."
          },
          "calculate_image_based_expansion_distance": {
            "default": false,
            "title": "Calculate Image Based Expansion Distance",
            "type": "boolean",
            "description": "If true, overrides any set expand_by_pixels value, and expansion distance is calculated based on the average label size in loaded region. In this case, expandby_factor must be supplied."
          },
          "expand_by_factor": {
            "title": "Expand By Factor",
            "type": "number",
            "description": "Only used if calculate_image_based_expansion_distance is True. Multiplier that specifies pixels by which to expand each label. Float in range [0, 1 or higher], e.g. 0.2 means that 20% of mean equivalent diameter of labels in region is used."
          },
          "fill_holes": {
            "default": false,
            "title": "Fill Holes",
            "type": "boolean",
            "description": "if True, the label image prior to expansion has holes filled by iterating over slices. Useful for filling lumens in segmentation."
          },
          "expand_in_z": {
            "default": false,
            "title": "Expand In Z",
            "type": "boolean",
            "description": "if True, uses different 3d expansion function to expand isotropically in z,y,x. Use with caution - anisotropic voxel spacing is not supported."
          }
        },
        "required": [
          "zarr_url",
          "label_name_to_expand"
        ],
        "type": "object",
        "title": "ExpandLabels"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Calculate Z-Illumination Correction",
      "input_types": {
        "z_illum_corrected": false,
        "is_3D": true
      },
      "category": "Image Processing",
      "modality": "HCS",
      "tags": [
        "3D",
        "illumination correction"
      ],
      "docs_info": "### Purpose\n- Apply z-illumination correction per object in 3D image.\n- Task takes as input user-defined channels and z-illumination correction tables,\n    and applies correction to the channel images. The channel of the table is matched to the channel of the\n    input image based on wavelength id or label. For multiplexing experiments, the user can specify which round(s) and\n    channel(s) the z-illumination correction should be applied to.\n- The z-illumination correction is applied per object, as different objects can have different z-illumination\n    profiles. The object segmentation image is provided with \"label_name\" and corresponding \"roi_table\" task inputs.\n    The label IDs of these objects must match the ID's that z-illumination calculation was run on (e.g. by running\n    Calculate Object Linking).\n- Processing proceeds as follows, with chunk-wise parallelization by Dask:\n- (1) The input correction table (anndata) is used to generate a 3D correction array that matches the size and\n    chunking of the label image. The correction array values are initialized to 1, and for regions where a segmented\n    object exists, 1 is replaced with the value of the z-correction table for the object and z-position. If the\n    correction table has been generated by the Calculate Z-Illumination Correction task, values of array are 0 to 1;\n    values closer to 0 will have a stronger correction.\n- (2) Background (user-specified per input channel) is subtracted from the channel image prior to correction. Task\n    assumes that background is not object-dependent.\n- (3) The channel image is divided element-wise by the correction array.\n- (4) Background is added back.\n\n### Outputs\n- Output is the input zarr image array, with channels selected for correction replaced with the corrected version.\n    Channels in zarr that were not selected but still present in zarr remain unmodified. The output zarr has data\n    type \"z_illum_corrected\", even if some channels remain uncorrected.\n- The user has option to overwrite input (=True), in which case the uncorrected zarr is deleted and replaced with\n    the corrected zarr. If False, a new zarr is generated (warning - this causes data duplication) with the\n    specified suffix added, output_group_suffix.\n",
      "executable_non_parallel": "fractal/init_select_multiplexing_round.py",
      "executable_parallel": "fractal/calculate_z_illumination_correction.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "selected_acquisition": {
            "default": 0,
            "title": "Selected Acquisition",
            "type": "integer",
            "description": "Which multiplexing round to select for processing. Uses the OME-NGFF HCS well metadata acquisition keys to find the round."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitSelectMultiplexingRound"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. This should be the image or multiplexing round that contains the uniform staining to be used for illumination correction."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Initialization arguments provided by `init_select_multiplexing_round`."
          },
          "input_channels": {
            "items": {
              "$ref": "#/$defs/ChannelInputModel"
            },
            "title": "Input Channels",
            "type": "array",
            "description": "list of ChannelInputModel objects, where the user specifies the channels for calculating correction (with wavelength id or label), within the round selected in the init task."
          },
          "label_name": {
            "default": "org",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of the 3D segmentation that identifies objects in image."
          },
          "roi_table": {
            "default": "org_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to label_name."
          },
          "percentile": {
            "default": 90,
            "title": "Percentile",
            "type": "integer",
            "description": "Integer value of percentile used to calculate intensity value of each z-slice. Recommended range is 80-90. Higher values (e.g. 99) are more sensitive to individual high-intensity in image, making the intensity vs. z curve less smooth. Lower values may pick up intensity of background or empty space in the image."
          },
          "low_bound_for_correction": {
            "default": 0.1,
            "title": "Low Bound For Correction",
            "type": "number",
            "description": "Float in range 0 to 1. Correction values below this value are clipped to this value and are thus not allowed to go below it. This ensures that overcorrection does not occur, e.g. if edges of object are not detected correctly. Recommended to set to ~ 0.1 - 0.05 (i.e. not more than 10-20x correction factor), otherwise when applied to image data the pixel values can become saturated."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "input_channels"
        ],
        "type": "object",
        "title": "CalculateZIlluminationCorrection"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Apply Z-Illumination Correction",
      "input_types": {
        "z_illum_corrected": false,
        "is_3D": true
      },
      "output_types": {
        "z_illum_corrected": true,
        "is_3D": true
      },
      "category": "Image Processing",
      "modality": "HCS",
      "tags": [
        "3D",
        "illumination correction"
      ],
      "docs_info": "### Purpose\n- Apply z-illumination correction per object in 3D image.\n- Task takes as input user-defined channels and z-illumination correction tables,\n    and applies correction to the channel images. The channel of the table is matched to the channel of the\n    input image based on wavelength id or label. For multiplexing experiments, the user can specify which round(s) and\n    channel(s) the z-illumination correction should be applied to.\n- The z-illumination correction is applied per object, as different objects can have different z-illumination\n    profiles. The object segmentation image is provided with \"label_name\" and corresponding \"roi_table\" task inputs.\n    The label IDs of these objects must match the ID's that z-illumination calculation was run on (e.g. by running\n    Calculate Object Linking).\n- Processing proceeds as follows, with chunk-wise parallelization by Dask:\n- (1) The input correction table (anndata) is used to generate a 3D correction array that matches the size and\n    chunking of the label image. The correction array values are initialized to 1, and for regions where a segmented\n    object exists, 1 is replaced with the value of the z-correction table for the object and z-position. If the\n    correction table has been generated by the Calculate Z-Illumination Correction task, values of array are 0 to 1;\n    values closer to 0 will have a stronger correction.\n- (2) Background (user-specified per input channel) is subtracted from the channel image prior to correction. Task\n    assumes that background is not object-dependent.\n- (3) The channel image is divided element-wise by the correction array.\n- (4) Background is added back.\n\n### Outputs\n- Output is the input zarr image array, with channels selected for correction replaced with the corrected version.\n    Channels in zarr that were not selected but still present in zarr remain unmodified. The output zarr has data\n    type \"z_illum_corrected\", even if some channels remain uncorrected.\n- The user has option to overwrite input (=True), in which case the uncorrected zarr is deleted and replaced with\n    the corrected zarr. If False, a new zarr is generated (warning - this causes data duplication) with the\n    specified suffix added, output_group_suffix.\n",
      "executable_non_parallel": "fractal/init_select_illumination_round.py",
      "executable_parallel": "fractal/apply_z_illumination_correction.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "illumination_correction_acquisition": {
            "default": 0,
            "title": "Illumination Correction Acquisition",
            "type": "integer",
            "description": "Which round was used for calculating illumination tables. Uses the OME-NGFF HCS well metadata acquisition keys to find the round."
          },
          "apply_correction_to_acquisitions": {
            "items": {
              "type": "integer"
            },
            "title": "Apply Correction To Acquisitions",
            "type": "array",
            "description": "List of rounds to which correction should be applied."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "apply_correction_to_acquisitions"
        ],
        "type": "object",
        "title": "InitSelectIlluminationRound"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsIllumination": {
            "description": "Registration init args.",
            "properties": {
              "correction_zarr_url": {
                "title": "Correction Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "correction_zarr_url"
            ],
            "title": "InitArgsIllumination",
            "type": "object"
          },
          "ZIlluminationChannelInputModel": {
            "description": "Extended version of ChannelInputModel with an additional attribute.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "z_correction_table": {
                "title": "Z Correction Table",
                "type": "string"
              },
              "background_intensity": {
                "default": 0,
                "title": "Background Intensity",
                "type": "integer"
              }
            },
            "title": "ZIlluminationChannelInputModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsIllumination",
            "title": "Init Args",
            "description": "Initialization arguments provided by `init_select_illumination_round`. It contains the zarr-url to the z-illumination correction round."
          },
          "input_channels": {
            "items": {
              "$ref": "#/$defs/ZIlluminationChannelInputModel"
            },
            "title": "Input Channels",
            "type": "array",
            "description": "list of ZIlluminationChannelInputModel objects, where the user specifies the channels for applying correction (with wavelength id or label), the corresponding name for the z-correction table, and the background for this channel. This setting will be applied to all rounds selected in the init task. If different values per round are desired, run separate instances of this task in the workflow."
          },
          "label_name": {
            "default": "org",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation (usually based on 2D MIP, converted to 3D) that identifies objects in image."
          },
          "roi_table": {
            "default": "org_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to label_name."
          },
          "overwrite_input": {
            "default": false,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "If True overwrites the original, uncorrected image with the output of this task."
          },
          "overwrite_output": {
            "default": false,
            "title": "Overwrite Output",
            "type": "boolean",
            "description": "If task has been run before and the corrected zarr with same name already exists, if set to True the previous output is overwritten."
          },
          "output_group_suffix": {
            "default": "zillum",
            "title": "Output Group Suffix",
            "type": "string",
            "description": "If overwrite_input=False, this suffix is added to the new OME-Zarr image that contains the z-illumination corrected images."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "input_channels"
        ],
        "type": "object",
        "title": "ApplyZIlluminationCorrection"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Fuse Touching Labels",
      "category": "Image Processing",
      "tags": [
        "2D"
      ],
      "docs_info": "### Purpose\n- Fuse touching labels in segmentation images, in 2D or 3D. Connected components are identified during labeling\n    based on the connectivity argument. For a more detailed explanation of 1- or 2- connectivity, see documentation\n    of skimage.measure.label() function. When set to None (default), full connectivity (ndim of input array) is used.\n\n- Input is segmentation image with 0 value for background. Anything above 0 is assumed to be a labeled object.\n    Touching labels are labeled in numerically increasing order starting from 1 to n, where n is the number of\n    connected components (objects) identified.\n\n- This task has been tested for fusion of 2D MIP segmentation. Since fusion must occur on the full well numpy\n    array loaded into memory, performance may be poor for large 3D arrays.\n\n### Outputs\n- The fused label image is saved as a new label in zarr, with name {label_name_to_fuse}_fused.\n- The new ROI table for the fused label image is saved as a masking ROI table, with name\n    {label_name_to_fuse}_fused_ROI_table.\n",
      "executable_parallel": "fractal/fuse_touching_labels.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed."
          },
          "label_name_to_fuse": {
            "default": "org",
            "title": "Label Name To Fuse",
            "type": "string",
            "description": "Label name of segmentation to be fused."
          },
          "new_label_name": {
            "title": "New Label Name",
            "type": "string",
            "description": "Optionally new name for expanded label. If left None, default is {label_name_to_fuse}_fused"
          },
          "connectivity": {
            "title": "Connectivity",
            "type": "integer",
            "description": "Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If None, a full connectivity of input.ndim is used."
          },
          "fill_holes": {
            "default": false,
            "title": "Fill Holes",
            "type": "boolean",
            "description": "if True, the label image after fusion has holes filled by iterating over slices. Useful for filling any gaps between fused labels."
          }
        },
        "required": [
          "zarr_url"
        ],
        "type": "object",
        "title": "FuseTouchingLabels"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "Convert 3D Segmentation to MIP",
      "input_types": {
        "is_3D": true
      },
      "output_types": {
        "is_3D": false
      },
      "tags": [
        "Mixed modality",
        "3D to 2D workflows"
      ],
      "docs_info": "### Purpose\n- Convert 3D segmentations into 2D maximum intensity projection (MIP) segmentations\n- Creates MIP along z axis\n- Useful for generating 2D MIP for multiplexed registration\n\n### Outputs\n- A new **MIP label image** saved as a label in the `_mip` 2D zarr.\n- A new **masking ROI table** saved as `{new_label_name}_ROI_table` in the 2D zarr.\n\n### Limitations\n- If multiple labels overlap along z, they are collapsed into a single value corresponding to the higher label id number (max) of the labels.\n",
      "executable_parallel": "fractal/convert_3d_to_mip.py",
      "meta_parallel": {
        "cpus_per_task": 2,
        "mem": 8000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Name of the label to copy from 3D OME-Zarr to 2D OME-Zarr"
          },
          "level": {
            "default": "0",
            "title": "Level",
            "type": "string",
            "description": "Level of the 3D OME-Zarr label to copy from. Valid choices are \"0\", \"1\", etc. (depending on which levels are available in the OME-Zarr label)."
          },
          "new_label_name": {
            "title": "New Label Name",
            "type": "string",
            "description": "Optionally overwriting the name of the label in the 2D OME-Zarr"
          },
          "plate_suffix": {
            "default": "_mip",
            "title": "Plate Suffix",
            "type": "string",
            "description": "Suffix that needs to be added to 3D OME-Zarr name to generate the path to the 2D OME-Zarr. If the 2D OME-Zarr is \"/path/to/my_plate_mip.zarr/B/03/0\" and the 3D OME-Zarr is located in \"/path/to/my_plate.zarr/B/03/0\", the correct suffix is \"_mip\"."
          },
          "image_suffix_3D_to_remove": {
            "title": "Image Suffix 3D To Remove",
            "type": "string",
            "description": "If the image name between 2D & 3D don't match, this is the suffix that should be removed from the 3D image. If the 3D image is in \"/path/to/my_plate.zarr/B/03/ 0_registered\" and the 2D image is in \"/path/to/my_plate_mip.zarr/ B/03/0\", the value should be \"_registered\""
          },
          "image_suffix_2D_to_add": {
            "title": "Image Suffix 2D To Add",
            "type": "string",
            "description": "If the image name between 2D & 3D don't match, this is the suffix that should be added to the 2D image. If the 3D image is in \"/path/to/my_plate.zarr/B/03/0\" and the 2D image is in \"/path/to/my_plate_mip.zarr/B/03/0_illum_corr\", the value should be \"_illum_corr\"."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite existing label and ROI tables in the 3D OME-Zarr"
          }
        },
        "required": [
          "zarr_url",
          "label_name"
        ],
        "type": "object",
        "title": "Convert3dToMip"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "Build Label Image",
      "category": "Image Processing",
      "tags": [
        "Mixed modality"
      ],
      "docs_info": "### Purpose\n- Clean up incomplete label image on disk\n- Build pyramid structure on disk for label image\n- Make masking ROI table based on label image\n- This is useful if a segmentation task was run but failed with OoM error at pyramid building step.\n- Works on both 2D and 3D zarr arrays\n\n### Outputs\n- Pyramid structure for label image (optional), matching chunking and number of levels of parent zarr array\n- Masking ROI table (optional)\n\n### Limitations\n- Only works for label images, not image arrays\n",
      "executable_parallel": "fractal/build_label_image.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 36000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation to be processed."
          },
          "build_zarr_pyramid": {
            "default": true,
            "title": "Build Zarr Pyramid",
            "type": "boolean",
            "description": "If True, build pyramid for input label_name."
          },
          "compute_masking_roi_table": {
            "default": true,
            "title": "Compute Masking Roi Table",
            "type": "boolean",
            "description": "If True, compute masking ROI table and save."
          },
          "new_table_name": {
            "title": "New Table Name",
            "type": "string",
            "description": "Optional name for ROI table. If left None, default is {label_name}_ROI_table."
          }
        },
        "required": [
          "zarr_url",
          "label_name"
        ],
        "type": "object",
        "title": "BuildLabelImage"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "Annotate Mesh by Child Features",
      "category": "Image Processing",
      "tags": [
        "3D",
        "mesh"
      ],
      "docs_info": "### Purpose\n- Annotate parent mesh (.stl) vertices (points) by child features\n- This allows visualization of single-cell features on tissue-scale mesh\n- For visualization in Paraview\n\n### Outputs\n- Saves .vtp mesh with embedded point annotations.\n\n### Limitations\n- Assumes feature extraction table and mesh have same physical unit spacing and scaling.\n- Each point of mesh is assigned to closest child object by euclidean distance to centroid.\n",
      "executable_parallel": "fractal/annotate_mesh_by_child_features.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 12000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "parent_mesh_name": {
            "title": "Parent Mesh Name",
            "type": "string",
            "description": "Mesh folder name on which annotation is performed. Must contain .stl format meshes whose filename corresponds to label name in ROI table."
          },
          "parent_roi_table": {
            "title": "Parent Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to labels of meshed objects, only used for indexing objects in for loop."
          },
          "child_feature_table": {
            "title": "Child Feature Table",
            "type": "string",
            "description": "Name of the feature table extracted from child objects. Assumes that it contains columns called ['x_pos_pix', 'y_pos_pix', 'z_pos_pix_scaled'] for the x,y,z centroids of each object. Assumes that these centroid units and scaling matches the mesh point units and scaling."
          },
          "annotate_by_features": {
            "items": {
              "type": "string"
            },
            "title": "Annotate By Features",
            "type": "array",
            "description": "List of strings. Each string is a column name of the child feature table and will be added to the .vtp mesh as a point annotation. Input should exactly match naming in child_feature_table columns. instance_key of child feature (e.g. \"label\") is added as column internally, so can be used as annotation feature as well."
          },
          "parent_of_child_colname": {
            "default": "ROI_label",
            "title": "Parent Of Child Colname",
            "type": "string",
            "description": "Name of column for parent label id's of child objects, e.g. the organoid id of the parent organoid. This column is assumed to be within obs of the child_feature_table. Usually this is defined in the feature extraction task."
          },
          "new_mesh_name": {
            "title": "New Mesh Name",
            "type": "string",
            "description": "Name of the new mesh folder where annotated .vtp meshes are saved."
          }
        },
        "required": [
          "zarr_url",
          "parent_mesh_name",
          "parent_roi_table",
          "child_feature_table",
          "annotate_by_features",
          "new_mesh_name"
        ],
        "type": "object",
        "title": "AnnotateMeshByChildFeatures"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "Cleanup 3D Child Labels",
      "category": "Image Processing",
      "tags": [
        "3D"
      ],
      "docs_info": "### Purpose\n- Clean up debris in label images\n- Remove labels that are smaller than specified volume threshold\n\n### Outputs\n- New label image and corresponding ROI table for cleaned objects\n\n### Limitations\n- Only performs volume-based filtering for now\n",
      "executable_parallel": "fractal/cleanup_3d_child_labels.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 12000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "child_label_name": {
            "default": "nuc",
            "title": "Child Label Name",
            "type": "string",
            "description": "Label name child objects (e.g. nuclei) to be cleaned."
          },
          "parent_label_name": {
            "title": "Parent Label Name",
            "type": "string",
            "description": "Label name of segmented objects that are parents of child_label_name. child_label_name objects will be masked and grouped by this object. For example, when parent_label_name = 'org', the nuclear segmentation is masked by the organoid parent and all nuclei belonging to the parent are loaded as a label image."
          },
          "parent_roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Parent Roi Table",
            "type": "string",
            "description": "Name of the ROI table used to iterate over objects and load object regions. This is the ROI table that corresponds to the parent_label_name objects."
          },
          "new_child_label_name": {
            "title": "New Child Label Name",
            "type": "string",
            "description": "New label name for cleaned child objects. If left None, default is {child_label_name}_cleaned."
          },
          "filter_children_by_volume": {
            "default": true,
            "title": "Filter Children By Volume",
            "type": "boolean",
            "description": "if True, performing volume filtering of children to remove objects smaller than specified volume_filter_threshold."
          },
          "child_volume_filter_threshold": {
            "default": 0.05,
            "title": "Child Volume Filter Threshold",
            "type": "number",
            "description": "Multiplier that specifies cutoff for volumes below which nuclei are filtered out, float in range [0,1], e.g. 0.05 means that 5% of median of nuclear volume distribution in a given object is used as cutoff. Default 0.05."
          },
          "repair_uint16_clipped_labels": {
            "default": false,
            "title": "Repair Uint16 Clipped Labels",
            "type": "boolean",
            "description": "If child labels were clipped to uint16 during segmentation and there were more than 2^16 labels, the label id's above 65535 get clipped. If True, these clipped values get remapped to monotonically increasing values 65536, 65537, etc."
          }
        },
        "required": [
          "zarr_url",
          "parent_label_name"
        ],
        "type": "object",
        "title": "Cleanup3dChildLabels"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Shift by Shift",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Copy and shift 2D or 3D label image from reference round to moving round(s)\n- Shift using pre-calculated x,y,z translations, e.g. from Calculate Linking Consensus task\n- Allows user to propogate segmentation run only on reference round to subsequent rounds, using rough registration\n- Useful for copying over organoid-level segmentation prior to more high-res registration on single-cell level\n\n### Outputs\n- A new **label image** saved as a label in moving rounds with '_shifted' suffix\n- A new corresponding **masking ROI table** saved as `{new_label_name}_ROI_table` in the moving rounds\n\n### Limitations\n- Applies x,y,z translation only\n- Translation must have been saved in a ROI table with columns \"translation_z\", \"translation_y\", \"translation_x\"\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/shift_by_shift.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name_to_shift": {
            "title": "Label Name To Shift",
            "type": "string",
            "description": "Label name of reference round to be copied and shifted."
          },
          "new_shifted_label_name": {
            "title": "New Shifted Label Name",
            "type": "string",
            "description": "Optionally new name for shifted label. If left None, default is {label_name}_shifted"
          },
          "translation_table_name": {
            "default": "well_ROI_table",
            "title": "Translation Table Name",
            "type": "string",
            "description": "ROI table name that contains the x,y,z translation information as columns \"translation_z\", \"translation_y\", \"translation_x\" in physical units. These are the shifts that should be applied to the moving image to match it to the reference round. If shifts are generated with the scMultiplex calculate object linking task, shifts are stored in the 'well_ROI_table'."
          },
          "zarr_suffix_to_add": {
            "title": "Zarr Suffix To Add",
            "type": "string",
            "description": "Optional suffix that needs to be added to input OME-Zarr name to generate the path to the registered OME-Zarr. If the registered OME-Zarr is \"/path/to/my_plate_mip.zarr/B/03/0\" and the input OME-Zarr is located in \"/path/to/my_plate.zarr/B/03/0\", the correct suffix is \"_mip\"."
          },
          "image_suffix_to_remove": {
            "title": "Image Suffix To Remove",
            "type": "string",
            "description": "If the image name between reference & registered zarrs don't match, this is the optional suffix that should be removed from the reference image. If the reference image is in \"/path/to/my_plate.zarr/B/03/ 0_registered\" and the registered image is in \"/path/to/my_plate_mip.zarr/ B/03/0\", the value should be \"_registered\""
          },
          "image_suffix_to_add": {
            "title": "Image Suffix To Add",
            "type": "string",
            "description": "If the image name between reference & registered zarrs don't match, this is the optional suffix that should be added to the reference image. If the reference image is in \"/path/to/my_plate.zarr/B/03/0\" and the registered image is in \"/path/to/my_plate_mip.zarr/B/03/0_illum_corr\", the value should be \"_illum_corr\"."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "label_name_to_shift"
        ],
        "type": "object",
        "title": "ShiftByShift"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Calculate Warpfield Registration",
      "input_types": {
        "is_3D": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- Calculate warpfield warp map between reference/moving object pairs in multiplexing rounds\n- GPU-based 3D non-rigid volumetric registration\n- See https://github.com/danionella/warpfield/tree/main\n\n### Outputs\n- Warmap for each moving object, saved in 'registration' folder as .npz file\n\n### Limitations\n- Uses masking ROI tables to load object pairs between reference/moving round\n- Assumes objects have been linked across rounds to have same label id and shape (no padding supported)\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/calculate_warpfield_registration.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000,
        "needs_gpu": true
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "registration_channel": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Registration Channel",
            "description": "Image channel to be used for registration. Must be present in both reference and moving rounds."
          },
          "roi_table_name": {
            "title": "Roi Table Name",
            "type": "string",
            "description": "Name of masking ROI table to be used for loading region pairs between rounds. The table must be present in both reference and moving rounds and correspond to segmented objects that have been linked (e.g. with Calculate Object Linking and Shift by Shift tasks). Each ref/mov object pair is expected to have matching label value and shape (bounding box dimension)."
          },
          "path_to_warpfield_recipe": {
            "title": "Path To Warpfield Recipe",
            "type": "string",
            "description": "Absolute path to warpfield recipe file. If None, default.yml is used."
          },
          "warpfield_pre_filter_clip_thresh": {
            "title": "Warpfield Pre Filter Clip Thresh",
            "type": "integer",
            "description": "Optional modifier of warpfield recipe. Pixel value threshold for clipping each volume. The default value in default.yml is 0. Higher values remove DC background."
          },
          "registration_name": {
            "default": "warpfield",
            "title": "Registration Name",
            "type": "string",
            "description": "Name of folder that contains warp map .npz files per moving object. Created as subfolder of 'registration' folder."
          },
          "overwrite_folder": {
            "default": false,
            "title": "Overwrite Folder",
            "type": "boolean",
            "description": "If True, clear existing subfolder {registration_name} in 'registration' folder to allow re-run of registration with same name."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "registration_channel",
          "roi_table_name"
        ],
        "type": "object",
        "title": "CalculateWarpfieldRegistration"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Apply Warpfield Registration",
      "input_types": {
        "registered": false,
        "is_3D": true
      },
      "output_types": {
        "registered": true,
        "is_3D": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- Apply warp map (output of calculate_warpfield_registration) to all channels of moving image.\n\n### Outputs\n- New registered 3D OME-Zarr image that is aligned to reference round\n- This image has same dimensions and placement of linked object regions as reference round\n- Label images and ROI tables are optionally copied to this new image\n\n### Limitations\n- Uses masking ROI tables to load object pairs between reference/moving round\n- Assumes objects have been linked across rounds to have same label id and shape (no padding supported)\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/apply_warpfield_registration.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000,
        "needs_gpu": true
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "roi_table_name": {
            "title": "Roi Table Name",
            "type": "string",
            "description": "Name of masking ROI table to be used for ROI loading. Typically, this is the same roi table used in the calculate_warpfield_registration task to load region pairs between rounds. Label ids and shape must correspond to the saved warp maps."
          },
          "registration_name": {
            "default": "warpfield",
            "title": "Registration Name",
            "type": "string",
            "description": "Name of folder that contains warp map .npz files per moving object. It is a subfolder of 'registration' folder, generated by the calculate_warpfield_registration task."
          },
          "output_image_suffix": {
            "default": "registered",
            "title": "Output Image Suffix",
            "type": "string",
            "description": "This suffix is added to the new OME-Zarr image that contains the registered corrected images. Fractal image list updated accordingly."
          },
          "mask_output_by_parent": {
            "default": false,
            "title": "Mask Output By Parent",
            "type": "boolean",
            "description": "If True, the registered image is masked by parent object label map after warpfield correction is applied. This ensures that there are no overlapping regions when writing ROIs to disk but may clip object at edges. If False, the new region is merged with the on-disk region by taking the element-wise maximum value. In cases of poor registration quality, this may cause shadowing (duplicated objects) and edge artifacts between regions."
          },
          "copy_labels_and_tables": {
            "default": false,
            "title": "Copy Labels And Tables",
            "type": "boolean",
            "description": "If True, all labels and tables are copied to the new moving OME-Zarr image from the reference zarr."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If True, overwrite existing OME-Zarr image (including all labels and tables)."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "roi_table_name"
        ],
        "type": "object",
        "title": "ApplyWarpfieldRegistration"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    }
  ],
  "has_args_schemas": true,
  "args_schema_version": "pydantic_v2",
  "authors": "Nicole Repina, Enrico Tagliavini, Tim-Oliver Buchholz, Joel Luethi"
}
