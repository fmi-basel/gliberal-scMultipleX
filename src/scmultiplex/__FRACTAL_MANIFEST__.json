{
  "manifest_version": "2",
  "task_list": [
    {
      "name": "scMultiplex Calculate Object Linking",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/calculate_object_linking.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Label name that will be used for label-based registration; e.g. `org` from object segmentation."
          },
          "roi_table": {
            "default": "well_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the well ROI table. Input ROI table must have single ROI entry; e.g. `well_ROI_table`"
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be processed. Choose `0` to process at full resolution."
          },
          "iou_cutoff": {
            "default": 0.2,
            "title": "Iou Cutoff",
            "type": "number",
            "description": "Float in range 0 to 1 to specify intersection over union cutoff. Object pairs that have an iou below this value are filtered out and not stored in linking table."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "label_name"
        ],
        "type": "object",
        "title": "CalculateObjectLinking"
      },
      "docs_info": "## _image_based_registration_hcs_init\nInitialized calculate registration task\n\nThis task prepares a parallelization list of all zarr_urls that need to be\nused to calculate the registration between acquisitions (all zarr_urls\nexcept the reference acquisition vs. the reference acquisition).\nThis task only works for HCS OME-Zarrs for 2 reasons: Only HCS OME-Zarrs\ncurrently have defined acquisition metadata to determine reference\nacquisitions. And we have only implemented the grouping of images for\nHCS OME-Zarrs by well (with the assumption that every well just has 1\nimage per acqusition).\n## calculate_object_linking\nCalculate object linking based on segmentation label map images\n\nThis task consists of 4 parts:\n\n1. Load the object segmentation images for each well (paired reference and alignment round)\n2. Calculate the shift transformation for the image pair\n3. Apply shifts to image pair and identify matching object labels given an iou cutoff threshold\n3. Store the identified matches as a linking table in alignment round directory\n\nParallelization level: image\n"
    },
    {
      "name": "scMultiplex Calculate Linking Consensus",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/calculate_linking_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "roi_table": {
            "default": "org_match_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the matching table used to calculate consensus across multiplexing rounds. Typically, this matching table is the output of a linking task, e.g. org_match_table or nuc_match_table. This table must be present in all rounds except for reference round."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "CalculateLinkingConsensus"
      },
      "docs_info": "## _init_group_by_well_for_multiplexing\nFinds images for all acquisitions per well.\n\nReturns the parallelization_list to run `find_registration_consensus`.\n## calculate_linking_consensus\nApplies pre-calculated registration to ROI tables.\n\nApply pre-calculated registration such that resulting ROIs contain\nthe consensus align region between all cycles.\n\nParallelization level: well\n"
    },
    {
      "name": "scMultiplex Relabel by Linking Consensus",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_allrounds_init.py",
      "executable_parallel": "fractal/relabel_by_linking_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 64000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsAllroundsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Label name to be relabeled; e.g. `org` or `nuc`."
          },
          "consensus_table": {
            "default": "org_match_table_consensus",
            "title": "Consensus Table",
            "type": "string",
            "description": "Name of consensus matching table that specifies consensus matches across rounds, typically stored in reference round zarr."
          },
          "table_to_relabel": {
            "default": "org_ROI_table",
            "title": "Table To Relabel",
            "type": "string",
            "description": "Table name to relabel based on consensus linking. The table rows correspond to specified 'Label name', e.g. 'org_ROI_table' or 'nuc_ROI_table'"
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "label_name"
        ],
        "type": "object",
        "title": "RelabelByLinkingConsensus"
      },
      "docs_info": "## _image_based_registration_hcs_allrounds_init\nInitialized calculate registration task\n\nSame as _image_based_registration_hcs_init.py only does not exclude reference round in zarr_url list;\nall rounds are processed.\n## relabel_by_linking_consensus\nRelabels image labels and ROI tables based on consensus linking.\n\nParallelization level: image\n"
    },
    {
      "name": "scMultiplex Calculate Platymatch Registration",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/calculate_platymatch_registration.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "seg_channel": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Seg Channel",
            "description": "Channel that was used for nuclear segmentation; requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`). Assume same across all rounds."
          },
          "label_name_to_register": {
            "default": "nuc",
            "title": "Label Name To Register",
            "type": "string",
            "description": "Label name that will be used for label-based registration, e.g. `nuc`."
          },
          "label_name_obj": {
            "default": "org_linked",
            "title": "Label Name Obj",
            "type": "string",
            "description": "Label name of segmented objects that is parent of label_name_to_register e.g. `org_linked`."
          },
          "roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. e.g. linked consensus object table 'org_ROI_table_linked'"
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the labels to register. Choose `0` to process at full resolution."
          },
          "save_transformation": {
            "default": true,
            "title": "Save Transformation",
            "type": "boolean",
            "description": "if True, saves the transformation matrix on disk in subfolder 'transformations'"
          },
          "mask_by_parent": {
            "default": true,
            "title": "Mask By Parent",
            "type": "boolean",
            "description": "if True, nuclei are masked by parent object (e.g. organoid) to only select nuclei belonging to parent. Recommended to set to True when iterating over object (e.g. organoid) ROIs."
          },
          "calculate_ffd": {
            "default": true,
            "title": "Calculate Ffd",
            "type": "boolean",
            "description": "if True, calculate free form deformation registration based on affine linking."
          },
          "volume_filter": {
            "default": true,
            "title": "Volume Filter",
            "type": "boolean",
            "description": "if True, performing volume filtering of nuclei to remove objects smaller than specified volume_filter_threshold."
          },
          "volume_filter_threshold": {
            "default": 0.05,
            "title": "Volume Filter Threshold",
            "type": "number",
            "description": "Multiplier that specifies cutoff for volumes below which nuclei are filtered out, float in range [0,1], e.g. 0.05 means that 5% of median of nuclear volume distribution is used as cutoff. Specify this value if volume filtering is desired. Default 0.05."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "seg_channel"
        ],
        "type": "object",
        "title": "CalculatePlatymatchRegistration"
      },
      "docs_info": "## _image_based_registration_hcs_init\nInitialized calculate registration task\n\nThis task prepares a parallelization list of all zarr_urls that need to be\nused to calculate the registration between acquisitions (all zarr_urls\nexcept the reference acquisition vs. the reference acquisition).\nThis task only works for HCS OME-Zarrs for 2 reasons: Only HCS OME-Zarrs\ncurrently have defined acquisition metadata to determine reference\nacquisitions. And we have only implemented the grouping of images for\nHCS OME-Zarrs by well (with the assumption that every well just has 1\nimage per acqusition).\n## calculate_platymatch_registration\nCalculate point-cloud-based registration with PlatyMatch.\n\nThis task consists of 4 parts:\n\n1. Load the sub-object segmentation images for each well (paired reference and alignment round)\n2. Select sub-objects that belong to object region by loading with object ROI table and mask by object mask.\n   Object pair is defined by consensus linking. Filter the sub-objects to remove small debris that was segmented.\n3. Calculate affine and optionally the free-form deformation for each object pair\n4. Output: save the identified matches as a linking table in alignment round directory\n   and optionally the transformation matrix on disk.\n\nParallelization level: image\n"
    },
    {
      "name": "scMultiplex Surface Mesh Multiscale",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/surface_mesh_multiscale.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "default": "nuc",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation for which mesh is calculated. When Multiscale = True, this is the label name of child objects (e.g. nuclei) that will be used for multiscale surface estimation."
          },
          "group_by": {
            "title": "Group By",
            "type": "string",
            "description": "Label name of segmentated objects that are parents of label_name. If None (default), no grouping is applied and meshes are calculated for the input object (label_name). Instead, if a group_by label is specified, the label_name objects will be masked and grouped by this object. For example, when group_by = 'org', the nuclear segmentation is masked by the organoid parent and all nuclei belonging to the parent are loaded as a label image. Thus, when Multiscale = False, the calculated mesh contains multiple child objects. When Multiscale = True, a new labelmap is generated as a result of child fusion to generate the 3D parent (organoid-level) shape."
          },
          "roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table used to iterate over objects and load object regions. If group_by = None, this is the ROI table that corresponds to the label_name objects. If group_by is passed, this is the ROI table for the group_by objects, e.g. org_ROI_table."
          },
          "multiscale": {
            "default": true,
            "title": "Multiscale",
            "type": "boolean",
            "description": "if True, a new labelmap is generated as a result of child fusion to generate the 3D parent (organoid-level) shape. This label output is called {group_by}_from_{label_name}, with corresponding ROI table name {group_by}_ROI_table_from_{label_name}. This label image is optionally saved as a mesh if save_mesh = True. If Multiscale = False, no multiscale label map computation is performed and a smoothened mesh of the input label_name is generated."
          },
          "save_mesh": {
            "default": true,
            "title": "Save Mesh",
            "type": "boolean",
            "description": "if True, calculates and saves mesh on disk in the 'meshes' folder within zarr structure. Meshes saved as '.stl', except for the case of multi-object meshed (e.g. multiple nuclei within a parent organoid) that are saved as '.vtp' to preserve label ID information. Filename corresponds to parent object label id, or to label id in the case when group_by = None."
          },
          "expandby_factor": {
            "default": 0.6,
            "title": "Expandby Factor",
            "type": "number",
            "description": "only used if Multiscale = True. Multiplier that specifies pixels by which to expand each nuclear mask for merging, float in range [0, 1 or higher], e.g. 0.2 means that 20% of mean of nuclear equivalent diameter is used."
          },
          "sigma_factor": {
            "default": 5,
            "title": "Sigma Factor",
            "type": "number",
            "description": "only used if Multiscale = True. Float that specifies sigma (standard deviation, in pixels) for Gaussian kernel used for blurring to smoothen label image prior to edge detection. Higher values correspond to more blurring. Recommended range 5-15."
          },
          "canny_threshold": {
            "default": 0.3,
            "title": "Canny Threshold",
            "type": "number",
            "description": "only used if Multiscale = True. Image values below this threshold are set to 0 after Gaussian blur. float in range [0,1]. Higher values result in tighter fit of mesh to nuclear surface."
          },
          "mask_contour_by_parent": {
            "default": false,
            "title": "Mask Contour By Parent",
            "type": "boolean",
            "description": "if True, the final multiscale edges are masking by 2D parent object mask. Can be used to define cleaner edge borders between touching organoids, but may crop surface mask if higher blurring is desired."
          },
          "volume_filter": {
            "default": false,
            "title": "Volume Filter",
            "type": "boolean",
            "description": "if True, performing volume filtering of nuclei to remove objects smaller than specified volume_filter_threshold."
          },
          "volume_filter_threshold": {
            "default": 0.05,
            "title": "Volume Filter Threshold",
            "type": "number",
            "description": "Multiplier that specifies cutoff for volumes below which nuclei are filtered out, float in range [0,1], e.g. 0.05 means that 5% of median of nuclear volume distribution is used as cutoff. Specify this value if volume filtering is desired. Default 0.05."
          },
          "polynomial_degree": {
            "default": 30,
            "title": "Polynomial Degree",
            "type": "integer",
            "description": "Mesh smoothing parameter. The number of polynomial degrees during surface mesh smoothing with vtkWindowedSincPolyDataFilter determines the maximum number of smoothing passes. This number corresponds to the degree of the polynomial that is used to approximate the windowed sinc function. Usually 10-20 iteration are sufficient. Higher values have little effect on smoothing. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "passband": {
            "default": 0.01,
            "title": "Passband",
            "type": "number",
            "description": "Mesh smoothing parameter. Float in range [0,2] that specifies the PassBand for the windowed sinc filter in vtkWindowedSincPolyDataFilter during mesh smoothing. Lower passband values produce more smoothing, due to filtering of higher frequencies. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "feature_angle": {
            "default": 160,
            "title": "Feature Angle",
            "type": "integer",
            "description": "Mesh smoothing parameter. Integer in range [0,180] that specifies the feature angle for sharp edge identification used for vtk FeatureEdgeSmoothing. Higher values result in more smoothened edges in mesh. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "target_reduction": {
            "default": 0.98,
            "title": "Target Reduction",
            "type": "number",
            "description": "Mesh decimation parameter. Float in range [0,1]. Target reduction is used during mesh decimation via vtkQuadricDecimation to reduce the number of triangles in a triangle mesh, forming a good approximation to the original geometry. Values closer to 1 indicate larger reduction and smaller mesh file size. Note that target_reduction is expressed as the fraction of the original number of triangles in mesh and so is proportional to original mesh size. Note the actual reduction may be less depending on triangulation and topological constraints. For further details see VTK vtkQuadricDecimation documentation."
          },
          "smoothing_iterations": {
            "default": 1,
            "title": "Smoothing Iterations",
            "type": "integer",
            "description": " Mesh smoothing parameter. The number of iterations that mesh smoothing and decimation is run. If smoothing_iterations > 1, the decimated result is used as input for subsequent smoothing rounds. Recommended to start with 1 iteration and increase if resulting smoothing is insufficient. For each iteration after the first, the passband is reduced and feature_angle is increased incrementally to enhance smoothing. Specifically, the passband is reduced by factor 1/(2^n), and the feature_angle is increased by an increment of (5 * n), where n = iteration round (n=0 is the first iteration). The target_reduction is fixed to 0.1 smoothing_iterations > 1. For example if user inputs (0.01, 160, 0.98) for (passband, feature_angle, target_reduction), the second iteration will use parameters (0.005, 165, 0.1), the third (0.0025, 170, 0.1), etc. Maximum feature_angle is capped at 180. Note that additional iterations usually do not significantly add to processing time as the number of mesh verteces is typically significantly reduced after the first decimation iteration."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "SurfaceMeshMultiscale"
      },
      "docs_info": "## _init_group_by_well_for_multiplexing\nFinds images for all acquisitions per well.\n\nReturns the parallelization_list to run `find_registration_consensus`.\n## surface_mesh_multiscale\nCalculate 3D surface mesh of parent object (e.g. tissue, organoid)\nfrom 3D cell-level segmentation of children (e.g. nuclei)\n\nRecommended to run on child objects that have been filtered to remove debris and disconnected components\n(e.g. following cleanup_3d_segmentation task)\n\nThis task consists of 4 parts:\n\n1. Load the sub-object (e.g. nuc) segmentation images for each object of a given reference round; skip other rounds.\n    Select sub-objects (e.g. nuc) that belong to parent object region by masking by parent.\n2. Perform label fusion and edge detection to generate surface label image.\n3. Calculate surface mesh of label image using vtkDiscreteFlyingEdges3D algorithm. Smoothing is applied with\n    vtkWindowedSincPolyDataFilter and tuned with 4 task parameters: passband, smoothing_iterations, feature_angle,\n    polynomial_degree (minimal effect).\n    The number of triangles in the mesh is optionally reduced with vtkQuadricDecimation filter to form a good\n    approximation to the original geometry and is tuned with task parameter target_reduction.\n4. Output: save the (1) meshes (.stl) per object id in meshes folder and (2) well label map as a new label in zarr.\n    Note that label map output may be clipped for objects that are dense and have overlapping pixels.\n    In this case, the 'winning' object in the overlap region is the one with higher label id.\n"
    },
    {
      "name": "scMultiplex Segment by Intensity Threshold",
      "executable_non_parallel": "fractal/init_select_multiplexing_round.py",
      "executable_parallel": "fractal/segment_by_intensity_threshold.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "selected_acquisition": {
            "default": 0,
            "title": "Selected Acquisition",
            "type": "integer",
            "description": "Which multiplexing round to select for processing. Uses the OME-NGFF HCS well metadata acquisition keys to find the round."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitSelectMultiplexingRound"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "default": "org",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation (usually based on 2D MIP) that identifies objects in image."
          },
          "roi_table": {
            "default": "org_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to label_name. This table is used to iterate over objects and load object regions."
          },
          "output_label_name": {
            "default": "org3d",
            "title": "Output Label Name",
            "type": "string",
            "description": "Desired name for new output label. The corresponding ROI table will be saved as {output_label_name}_ROI_table."
          },
          "channel_1": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Channel 1",
            "description": "Channel of raw image used for thresholding. Requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`)."
          },
          "background_channel_1": {
            "default": 800,
            "title": "Background Channel 1",
            "type": "integer",
            "description": "Pixel intensity value of background to subtract from channel 1 raw image."
          },
          "maximum_channel_1": {
            "title": "Maximum Channel 1",
            "type": "integer",
            "description": "Maximum pixel intensity value that channel 1 image is rescaled to."
          },
          "weight_channel_1": {
            "default": 0.5,
            "title": "Weight Channel 1",
            "type": "number",
            "description": "Float specifying weight of channel 1 image. Channels are combined as (weight_channel_1 * ch1_raw) + (weight_channel_2 * ch2_raw). When both weights are 0.5, channels are averaged."
          },
          "channel_2": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Channel 2",
            "description": "Channel of second raw image to be combined with channel 1 image. Requires either `wavelength_id` (e.g. `A02_C02`) or `label` (e.g. `BCAT`)."
          },
          "background_channel_2": {
            "default": 400,
            "title": "Background Channel 2",
            "type": "integer",
            "description": "Pixel intensity value of background to subtract from channel 2 raw image."
          },
          "maximum_channel_2": {
            "title": "Maximum Channel 2",
            "type": "integer",
            "description": "Maximum pixel intensity value that channel 1 image is rescaled to."
          },
          "weight_channel_2": {
            "default": 0.5,
            "title": "Weight Channel 2",
            "type": "number",
            "description": "Float specifying weight of channel 2 image. Channels are combined as (weight_channel_1 * ch1_raw) + (weight_channel_2 * ch2_raw)"
          },
          "otsu_threshold": {
            "default": true,
            "title": "Otsu Threshold",
            "type": "boolean",
            "description": "if True, the threshold for each region is calculated with the Otsu method. This threshold method is more robust to intensity variation between objects compared to intensity_threshold."
          },
          "otsu_weight": {
            "default": 1.0,
            "title": "Otsu Weight",
            "type": "number",
            "description": "Scale calculated Otsu threhsold by this value. Values lower than 1 (e.g. 0.9) reduce Otsu threshold (e.g. by 10 %) to include lower-intensity pixels in thresholding."
          },
          "intensity_threshold": {
            "default": -1,
            "title": "Intensity Threshold",
            "type": "integer",
            "description": "Integer that specifies threshold intensity value to binarize image. Must be supplied if Otsu thresholding is not used. Intensities below this value will be set to 0, intensities above are set to 1. The specified value should correspond to intensity range of raw image (e.g. for 16-bit images, 0-65535). Recommended threshold value is above image background level and below dimmest regions of image, particularly at deeper z-depth."
          },
          "gaussian_sigma_raw_image": {
            "default": 30,
            "title": "Gaussian Sigma Raw Image",
            "type": "number",
            "description": "Float that specifies sigma (standard deviation, in pixels) for 3D Gaussian kernel used for blurring of raw intensity image prior to thresholding and edge detection. Higher values correspond to more blurring that reduce holes in thresholded image. Recommended range 10-40."
          },
          "gaussian_sigma_threshold_image": {
            "default": 20,
            "title": "Gaussian Sigma Threshold Image",
            "type": "number",
            "description": "Float that specifies sigma (standard deviation, in pixels) for 2D Gaussian kernel used for blurring each z-slice of thresholded binary image prior to edge detection. Higher values correspond to more blurring and smoother surface edges. Recommended range 10-30."
          },
          "small_objects_diameter": {
            "default": 30,
            "title": "Small Objects Diameter",
            "type": "number",
            "description": "Float that specifies the approximate diameter, in pixels and at level=0, of debris in the image. This value is used to filter out small objects using skimage.morphology.remove_small_objects."
          },
          "expand_by_pixels": {
            "default": 20,
            "title": "Expand By Pixels",
            "type": "integer",
            "description": "Expand initial threshold mask by this number of pixels and fill holes. Mask is subsequently dilated and returned to original size. This step serves to fill holes in dim regions. Higher values lead to more holes filled, but neighboring objects or debris may become fused."
          },
          "canny_threshold": {
            "default": 0.4,
            "title": "Canny Threshold",
            "type": "number",
            "description": "Float in range [0,1]. Image values below this threshold are set to 0 after Gaussian blur using gaus_sigma_thresh_img. Higher threshold values result in tighter fit of edge mask to intensity image."
          },
          "linear_z_illumination_correction": {
            "default": false,
            "title": "Linear Z Illumination Correction",
            "type": "boolean",
            "description": "Set to True if linear z illumination correction is desired. Iterate over z-slices to apply correction."
          },
          "start_z_slice": {
            "default": 40,
            "title": "Start Z Slice",
            "type": "integer",
            "description": "Z-slice number at which to begin to apply linear correction, e.g. slice 40 if image stack has 100 slices."
          },
          "m_slope": {
            "default": 0.015,
            "title": "M Slope",
            "type": "number",
            "description": "Slope factor of illumination correction. Higher values have more extreme correction. This value sets the multiplier for a given z-slice by formula m_slope * (i - start_z_slice) + 1, where i is the current z-slice in iterator."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "channel_1",
          "maximum_channel_1",
          "channel_2",
          "maximum_channel_2"
        ],
        "type": "object",
        "title": "SegmentByIntensityThreshold"
      },
      "docs_info": "## init_select_multiplexing_round\nFinds images for desired acquisition per well.\n\nReturns the parallelization_list.\n## segment_by_intensity_threshold\nCalculate full 3D object segmentation after 2D MIP-based segmentation using intensity thresholding of\nraw intensity image(s).\n\nThis task consists of 3 parts:\n\n1. Load the intensity images for selected channels using MIP-based segmentation ROIs.\n2. Generate 3D mask based on simple thresholding of the combined channel images. The thresholded image is\n    smoothened using gaussian blurring followed by Canny edge detection. Optional z-illumination correctopn\n    is applied on the fly. The MIP-based segmentation is used to mask\n    the resulting label image to roughly exclude any neighboring organoids and debris. To further exclude\n    neighboring organoids and debris, the largest connected component is selected as the final label image.\n3. Output: save the (1) new label image and (2) new masking ROI table in the selected zarr url.\n"
    },
    {
      "name": "scMultiplex Spherical Harmonics from Label Image",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/spherical_harmonics_from_labelimage.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "default": "org_3d",
            "title": "Label Name",
            "type": "string",
            "description": "Label for which spherical harmonics are calculated"
          },
          "roi_table": {
            "default": "org_ROI_table_3d",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. e.g. consensus object table 'org_ROI_table_consensus'"
          },
          "lmax": {
            "default": 2,
            "title": "Lmax",
            "type": "integer",
            "description": "Maximum degree of the spherical harmonics coefficients"
          },
          "save_mesh": {
            "default": true,
            "title": "Save Mesh",
            "type": "boolean",
            "description": "If True, saves the computed surface mesh (with vtkContourFilter in aics_shparam functions) on disk in subfolder 'meshes'. Filename corresponds to object label id"
          },
          "save_reconstructed_mesh": {
            "default": true,
            "title": "Save Reconstructed Mesh",
            "type": "boolean",
            "description": "If true, reconstruct mesh from spherical harmonics and save as stl in meshes zarr directory. Filename corresponds to object label id"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "SphericalHarmonicsFromLabelimage"
      },
      "docs_info": "## _init_group_by_well_for_multiplexing\nFinds images for all acquisitions per well.\n\nReturns the parallelization_list to run `find_registration_consensus`.\n## spherical_harmonics_from_labelimage\nCalculate spherical harmonics of 3D input label image using aics_shparam.\n\nThis task consists of 6 parts:\n\n1. Load 3D label image based on provided label name and ROI table\n2. Compute 3D mesh with vtkContourFilter using aics_shparam functions\n3. Compute spherical harmonics of mesh using aics_shparam\n4. Compute reconstruction error (mse) of computed harmonics\n5. Optionally generate reconstructed mesh from the calculated harmonics\n6. Output: save the (1) spherical harmonic coefficients and mse error as feature table\n    (2) reconstructed meshes (.stl) per object id in a new meshes folder within zarr structure\n"
    },
    {
      "name": "scMultiplex Mesh Measurements",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/scmultiplex_mesh_measurements.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Initialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "mesh_name": {
            "title": "Mesh Name",
            "type": "string",
            "description": "Mesh folder name for which features are to be extracted. Must contain .stl format meshes whose filename corresponds to label name in ROI table."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to labels of meshed objects, only used for indexing objects"
          },
          "output_table_name": {
            "title": "Output Table Name",
            "type": "string",
            "description": "Name of the output AnnData table to save the measurements in. A table of this name can't exist yet in the OME-Zarr file"
          },
          "save_hulls": {
            "default": true,
            "title": "Save Hulls",
            "type": "boolean",
            "description": "if True, save the calculated convex hull and bounding box as .vtp meshes within meshes/[mesh_name]_convex_hull and meshes/[mesh_name]_bounding_box directories"
          },
          "calculate_curvature": {
            "default": true,
            "title": "Calculate Curvature",
            "type": "boolean",
            "description": "if True, calculate Gaussian curvature at each mesh point and save as .vtp mesh on disk within meshes/[mesh_name]_curvature folder in zarr structure. Filename corresponds to object label id."
          },
          "calculate_harmonics": {
            "default": true,
            "title": "Calculate Harmonics",
            "type": "boolean",
            "description": "if True, calculate spherical harmonics of mesh using aics_shparam"
          },
          "lmax": {
            "default": 2,
            "title": "Lmax",
            "type": "integer",
            "description": "Maximum degree of the spherical harmonics coefficients"
          },
          "translate_to_origin": {
            "default": true,
            "title": "Translate To Origin",
            "type": "boolean",
            "description": "If true, translate centroid of mesh to origin prior to spherical harmonic decomposition. Recommended set to True"
          },
          "save_reconstructed_mesh": {
            "default": true,
            "title": "Save Reconstructed Mesh",
            "type": "boolean",
            "description": "If true, reconstruct mesh from spherical harmonics and save as stl in meshes zarr directory"
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "mesh_name",
          "roi_table",
          "output_table_name"
        ],
        "type": "object",
        "title": "ScmultiplexMeshMeasurements"
      },
      "docs_info": "## _init_group_by_well_for_multiplexing\nFinds images for all acquisitions per well.\n\nReturns the parallelization_list to run `find_registration_consensus`.\n## scmultiplex_mesh_measurements\nExtract shape features of 3D input meshes.\n\nThis task consists of 5 parts:\n\n1. Load meshes (.stl) from zarr structure that have been previously generated\n    (e.g. using Surface Mesh Multiscale task)\n2. Extract mesh morphology measurements: volume, surface area, extent, solidity, concavity, asymmetry,\n    aspect ratio, and normalized surface area to volume ratio. Units correspond to units of mesh. If mesh was\n    generated with surface_mesh_multiscale task, units are physical units (um). For further details of features see\n    scMultiplex FeatureFunctions.py\n3. Optionally calculate Gaussian curvature at each mesh point (set calculate_curvature = True)\n4. Optionally compute spherical harmonics of mesh using aics_shparam (set calculate_harmonics = True).\n    Compute reconstruction error (mse) of computed harmonics and optionally generate reconstructed mesh from the\n    calculated harmonics\n5. Output: save (1) extracted measurements as a new table (output_table_name), (2) optional spherical harmonic\n    coefficients and mse error as a separate feature table ('output_table_name'_harmonics) (3) optional\n    reconstructed meshes from spherical harmonics as .stl within zarr structure (3) optional convex hull\n    and bounding box on disk as .vtp within zarr structure (4) optional curvature meshes on disk as .vtp within\n    zarr structure.\n"
    },
    {
      "name": "scMultiplex Feature Measurements",
      "executable_parallel": "fractal/scmultiplex_feature_measurements.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_image": {
            "title": "Label Image",
            "type": "string",
            "description": "Name of the label image to use for measurements. Needs to exist in OME-Zarr file"
          },
          "output_table_name": {
            "title": "Output Table Name",
            "type": "string",
            "description": "Name of the output AnnData table to save the measurements in. A table of this name can't exist yet in the OME-Zarr file"
          },
          "input_channels": {
            "additionalProperties": {
              "$ref": "#/$defs/ChannelInputModel"
            },
            "title": "Input Channels",
            "type": "object",
            "description": "Dictionary of channels to measure. Keys are the names that will be added as prefixes to the measurements, values are another dictionary containing either wavelength_id or channel_label information to allow Fractal to find the correct channel (but not both). Example: {\"C01\": {\"wavelength_id\": \"A01_C01\"}. To only measure morphology, provide an empty dict"
          },
          "input_ROI_table": {
            "default": "well_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table to loop over. Needs to exists as a ROI table in the OME-Zarr file"
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Resolution of the intensity image to load for measurements. Only tested for level 0"
          },
          "label_level": {
            "default": 0,
            "title": "Label Level",
            "type": "integer",
            "description": "Resolution of the label image to load for measurements."
          },
          "measure_morphology": {
            "default": true,
            "title": "Measure Morphology",
            "type": "boolean",
            "description": "Set to True to measure morphology features"
          },
          "allow_duplicate_labels": {
            "default": false,
            "title": "Allow Duplicate Labels",
            "type": "boolean",
            "description": "Set to True to allow saving measurement tables with non-unique label values. Can happen when segmentation is run on a different ROI than the measurements (e.g. segment per well, but measure per FOV)"
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_url",
          "label_image",
          "output_table_name"
        ],
        "type": "object",
        "title": "ScmultiplexFeatureMeasurements"
      },
      "docs_info": "## scmultiplex_feature_measurements\nMeasurements of intensities and morphologies\n\nWrapper task for scmultiplex measurements for Fractal to generate\nmeasurements of intensities and morphologies\n"
    }
  ],
  "has_args_schemas": true,
  "args_schema_version": "pydantic_v2"
}
