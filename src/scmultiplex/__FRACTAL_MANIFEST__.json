{
  "manifest_version": "2",
  "task_list": [
    {
      "name": "scMultiplex Calculate Object Linking",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "2D"
      ],
      "docs_info": "### Purpose\n- Links segmented objects between a reference and an alignment acquisition within a single well of an HCS OME-Zarr dataset.\n- Calculates object shifts using segmentation label maps, aligns objects, and identifies matching labels based on an Intersection over Union (IoU) cutoff threshold.\n- Generates a linking table that maps object labels from the reference acquisition to those in the alignment acquisition.\n\n### Outputs\n- A linking table stored in the alignment acquisition directory.\n- The table includes matched object pairs and their IoU scores.\n\n### Limitations\n- Only works for HCS OME-Zarr datasets where a **single well ROI** is used for linking. Multi-ROI processing (e.g., for FOV ROI tables) is not yet supported.\n- Requires segmentation label maps to be provided for both the reference and alignment acquisitions.\n- Matching is performed using an IoU threshold; objects below the threshold are not linked.\n- Pixel sizes must match between the reference and alignment acquisitions for accurate registration.\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/calculate_object_linking.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Label name that will be used for label-based registration; e.g. `org` from object segmentation."
          },
          "roi_table": {
            "default": "well_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the well ROI table. Input ROI table must have single ROI entry; e.g. `well_ROI_table`"
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be processed. Choose `0` to process at full resolution."
          },
          "iou_cutoff": {
            "default": 0.2,
            "title": "Iou Cutoff",
            "type": "number",
            "description": "Float in range 0 to 1 to specify intersection over union cutoff. Object pairs that have an iou below this value are filtered out and not stored in linking table."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "label_name"
        ],
        "type": "object",
        "title": "CalculateObjectLinking"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Calculate Linking Consensus",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Calculates a **consensus linking table** across all multiplexing rounds in an HCS OME-Zarr dataset.\n- Aligns object labels from all acquisitions to a reference acquisition, ensuring consistent object identities across rounds.\n- Stores the resulting consensus table in the reference acquisition directory.\n\n### Outputs\n- A **consensus linking table** that maps object labels from all rounds to a single, aligned consensus.\n- The table includes:\n  - Original object labels from each round (e.g., `R0_label`, `R1_label`, ...).\n  - A new consensus label (`consensus_label`) and index (`consensus_index`) for aligned objects.\n\n### Limitations\n- Requires pre-existing linking tables generated by a previous linking task (e.g., `Calculate Object Linking`).\n- Assumes that the input linking tables follow a consistent structure across rounds.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/calculate_linking_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "roi_table": {
            "default": "org_match_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the matching table used to calculate consensus across multiplexing rounds. Typically, this matching table is the output of a linking task, e.g. org_match_table or nuc_match_table. This table must be present in all rounds except for reference round."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "CalculateLinkingConsensus"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Relabel by Linking Consensus",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Relabels segmentation images and ROI tables in an OME-Zarr dataset based on a pre-calculated **consensus linking table**.\n- Aligns object labels across multiplexing rounds to ensure consistency with the consensus object identities.\n- Outputs new segmentation images and ROI tables with updated labels.\n- Requires a valid **consensus linking table** as input, typically generated by the `Calculate Linking Consensus` task.\n- Non-consensus objects are set to background and excluded from the outputs.\n\n### Outputs\n- A **new segmentation image** where object labels match the consensus labels.\n- A **relabelled ROI table** corresponding to the updated segmentation image, saved with a `_linked` suffix.\n\n### Limitations\n- Only supports **single well ROI tables**; multi-ROI processing (e.g., field of view ROIs) is not yet implemented.\n- Input segmentation images and ROI tables must match in terms of object labels; inconsistencies will cause errors.\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_allrounds_init.py",
      "executable_parallel": "fractal/relabel_by_linking_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 64000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsAllroundsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Label name to be relabeled; e.g. `org` or `nuc`."
          },
          "consensus_table": {
            "default": "org_match_table_consensus",
            "title": "Consensus Table",
            "type": "string",
            "description": "Name of consensus matching table that specifies consensus matches across rounds, typically stored in reference round zarr."
          },
          "table_to_relabel": {
            "default": "org_ROI_table",
            "title": "Table To Relabel",
            "type": "string",
            "description": "Table name to relabel based on consensus linking. The table rows correspond to specified 'Label name', e.g. 'org_ROI_table' or 'nuc_ROI_table'"
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "label_name"
        ],
        "type": "object",
        "title": "RelabelByLinkingConsensus"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Calculate Platymatch Registration",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- Calculates point-cloud-based registration between segmentation images using **PlatyMatch**.\n- Works well for **complex 3D registration**.\n- Aligns sub-objects (e.g., nuclei) that belong to parent objects (e.g., organoids) by calculating **affine** and optionally **free-form deformation** transformations.\n- Outputs linking tables of matched sub-objects and optionally saves transformation matrices to disk.\n\n### Outputs\n- A **linking table** that maps sub-objects between reference and alignment rounds using affine and/or free-form deformation (FFD) transformations.\n- Transformation matrices (optional), saved on disk for each object pair.\n\n### Limitations\n- Only supports **single well ROI tables**; multi-ROI processing (e.g., FOV ROIs) is not yet implemented.\n- Requires parent objects to be linked in a prior step using a **consensus linking table**.\n- Assumes consistent pixel sizes between reference and alignment rounds for accurate registration.\n- Relies on sufficient sub-object counts for alignment; regions with fewer than 3 sub-objects are skipped.\n",
      "executable_non_parallel": "fractal/_image_based_registration_hcs_init.py",
      "executable_parallel": "fractal/calculate_platymatch_registration.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "ImageBasedRegistrationHcsInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `_image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "seg_channel": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Seg Channel",
            "description": "Channel that was used for nuclear segmentation; requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`). Assume same across all rounds."
          },
          "label_name_to_register": {
            "default": "nuc",
            "title": "Label Name To Register",
            "type": "string",
            "description": "Label name that will be used for label-based registration, e.g. `nuc`."
          },
          "label_name_obj": {
            "default": "org_linked",
            "title": "Label Name Obj",
            "type": "string",
            "description": "Label name of segmented objects that is parent of label_name_to_register e.g. `org_linked`."
          },
          "roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. e.g. linked consensus object table 'org_ROI_table_linked'"
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the labels to register. Choose `0` to process at full resolution."
          },
          "save_transformation": {
            "default": true,
            "title": "Save Transformation",
            "type": "boolean",
            "description": "if True, saves the transformation matrix on disk in subfolder 'transformations'"
          },
          "mask_by_parent": {
            "default": true,
            "title": "Mask By Parent",
            "type": "boolean",
            "description": "if True, nuclei are masked by parent object (e.g. organoid) to only select nuclei belonging to parent. Recommended to set to True when iterating over object (e.g. organoid) ROIs."
          },
          "calculate_ffd": {
            "default": true,
            "title": "Calculate Ffd",
            "type": "boolean",
            "description": "if True, calculate free form deformation registration based on affine linking."
          },
          "volume_filter": {
            "default": true,
            "title": "Volume Filter",
            "type": "boolean",
            "description": "if True, performing volume filtering of nuclei to remove objects smaller than specified volume_filter_threshold."
          },
          "volume_filter_threshold": {
            "default": 0.05,
            "title": "Volume Filter Threshold",
            "type": "number",
            "description": "Multiplier that specifies cutoff for volumes below which nuclei are filtered out, float in range [0,1], e.g. 0.05 means that 5% of median of nuclear volume distribution is used as cutoff. Specify this value if volume filtering is desired. Default 0.05."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "seg_channel"
        ],
        "type": "object",
        "title": "CalculatePlatymatchRegistration"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Surface Mesh Multiscale",
      "category": "Image Processing",
      "modality": "HCS",
      "tags": [
        "3D",
        "mesh"
      ],
      "docs_info": "### Purpose\n- Calculates **3D surface meshes** for parent objects (e.g., tissues, organoids) based on 3D child-level segmentation (e.g., nuclei).\n- Optionally applies **multiscale label fusion** to estimate a smooth parent shape by merging child objects.\n- Generates smoothened surface meshes using **VTK algorithms**, with optional mesh decimation for reduced complexity.\n- Outputs 3D meshes in `.stl` or `.vtp` format and a new well label map in the dataset.\n\n### Outputs\n- **Surface meshes** of parent objects, saved as `.stl` (single object) or `.vtp` (multi-object) files in the dataset\u2019s `meshes` folder.\n- A **new label map** containing fused child-level objects, saved in the OME-Zarr dataset (only if multiscale processing is enabled).\n- A **bounding-box ROI table** corresponding to the new label map.\n\n### Limitations\n- Requires pre-segmented child objects and a parent object ROI table.\n- Multiscale processing requires a **parent label** for accurate object grouping and fusion.\n- Label map outputs may have **overlaps clipped**, where higher-label IDs take precedence in dense regions.\n- Mesh quality can vary with complex geometries; manual tuning of smoothing parameters may be needed for optimal results.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/surface_mesh_multiscale.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "default": "nuc",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation for which mesh is calculated. When Multiscale = True, this is the label name of child objects (e.g. nuclei) that will be used for multiscale surface estimation."
          },
          "group_by": {
            "title": "Group By",
            "type": "string",
            "description": "Label name of segmentated objects that are parents of label_name. If None (default), no grouping is applied and meshes are calculated for the input object (label_name). Instead, if a group_by label is specified, the label_name objects will be masked and grouped by this object. For example, when group_by = 'org', the nuclear segmentation is masked by the organoid parent and all nuclei belonging to the parent are loaded as a label image. Thus, when Multiscale = False, the calculated mesh contains multiple child objects. When Multiscale = True, a new labelmap is generated as a result of child fusion to generate the 3D parent (organoid-level) shape."
          },
          "roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table used to iterate over objects and load object regions. If group_by = None, this is the ROI table that corresponds to the label_name objects. If group_by is passed, this is the ROI table for the group_by objects, e.g. org_ROI_table."
          },
          "multiscale": {
            "default": true,
            "title": "Multiscale",
            "type": "boolean",
            "description": "if True, a new labelmap is generated as a result of child fusion to generate the 3D parent (organoid-level) shape. This label output is called {group_by}_from_{label_name}, with corresponding ROI table name {group_by}_ROI_table_from_{label_name}. This label image is optionally saved as a mesh if save_mesh = True. If Multiscale = False, no multiscale label map computation is performed and a smoothened mesh of the input label_name is generated."
          },
          "save_mesh": {
            "default": true,
            "title": "Save Mesh",
            "type": "boolean",
            "description": "if True, calculates and saves mesh on disk in the 'meshes' folder within zarr structure. Meshes saved as '.stl', except for the case of multi-object meshed (e.g. multiple nuclei within a parent organoid) that are saved as '.vtp' to preserve label ID information. Filename corresponds to parent object label id, or to label id in the case when group_by = None."
          },
          "expandby_factor": {
            "default": 0.6,
            "title": "Expandby Factor",
            "type": "number",
            "description": "only used if Multiscale = True. Multiplier that specifies pixels by which to expand each nuclear mask for merging, float in range [0, 1 or higher], e.g. 0.2 means that 20% of mean of nuclear equivalent diameter is used."
          },
          "sigma_factor": {
            "default": 5,
            "title": "Sigma Factor",
            "type": "number",
            "description": "only used if Multiscale = True. Float that specifies sigma (standard deviation, in pixels) for Gaussian kernel used for blurring to smoothen label image prior to edge detection. Higher values correspond to more blurring. Recommended range 5-15."
          },
          "canny_threshold": {
            "default": 0.3,
            "title": "Canny Threshold",
            "type": "number",
            "description": "only used if Multiscale = True. Image values below this threshold are set to 0 after Gaussian blur. float in range [0,1]. Higher values result in tighter fit of mesh to nuclear surface."
          },
          "mask_contour_by_parent": {
            "default": false,
            "title": "Mask Contour By Parent",
            "type": "boolean",
            "description": "if True, the final multiscale edges are masking by 2D parent object mask. Can be used to define cleaner edge borders between touching organoids, but may crop surface mask if higher blurring is desired."
          },
          "fill_holes": {
            "default": false,
            "title": "Fill Holes",
            "type": "boolean",
            "description": "if True, the label image just prior to meshing has holes filled by iterating over slices. Useful for filling lumens in segmentation."
          },
          "filter_by_object_volume": {
            "default": false,
            "title": "Filter By Object Volume",
            "type": "boolean",
            "description": "if True, the label image is filtered by volume. This skips objects with lower volume (number of pixels, calculated after all processing and hole filling, if applied) than the object_volume_filter_threshold."
          },
          "object_volume_filter_threshold": {
            "default": 60000,
            "title": "Object Volume Filter Threshold",
            "type": "integer",
            "description": "Integer threshold for object volume filtering. Number of pixels. E.g. if set to 600, objects with a pixel count less than 600 are skipped. Only used if filter_by_object_volume is True."
          },
          "filter_children_by_volume": {
            "default": false,
            "title": "Filter Children By Volume",
            "type": "boolean",
            "description": "if True, performing volume filtering of nuclei to remove objects smaller than specified volume_filter_threshold."
          },
          "child_volume_filter_threshold": {
            "default": 0.05,
            "title": "Child Volume Filter Threshold",
            "type": "number",
            "description": "Multiplier that specifies cutoff for volumes below which nuclei are filtered out, float in range [0,1], e.g. 0.05 means that 5% of median of nuclear volume distribution is used as cutoff. Specify this value if volume filtering is desired. Default 0.05."
          },
          "polynomial_degree": {
            "default": 30,
            "title": "Polynomial Degree",
            "type": "integer",
            "description": "Mesh smoothing parameter. The number of polynomial degrees during surface mesh smoothing with vtkWindowedSincPolyDataFilter determines the maximum number of smoothing passes. This number corresponds to the degree of the polynomial that is used to approximate the windowed sinc function. Usually 10-20 iteration are sufficient. Higher values have little effect on smoothing. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "passband": {
            "default": 0.01,
            "title": "Passband",
            "type": "number",
            "description": "Mesh smoothing parameter. Float in range [0,2] that specifies the PassBand for the windowed sinc filter in vtkWindowedSincPolyDataFilter during mesh smoothing. Lower passband values produce more smoothing, due to filtering of higher frequencies. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "feature_angle": {
            "default": 160,
            "title": "Feature Angle",
            "type": "integer",
            "description": "Mesh smoothing parameter. Integer in range [0,180] that specifies the feature angle for sharp edge identification used for vtk FeatureEdgeSmoothing. Higher values result in more smoothened edges in mesh. For further details see VTK vtkWindowedSincPolyDataFilter documentation."
          },
          "target_reduction": {
            "default": 0.98,
            "title": "Target Reduction",
            "type": "number",
            "description": "Mesh decimation parameter. Float in range [0,1]. Target reduction is used during mesh decimation via vtkQuadricDecimation to reduce the number of triangles in a triangle mesh, forming a good approximation to the original geometry. Values closer to 1 indicate larger reduction and smaller mesh file size. Note that target_reduction is expressed as the fraction of the original number of triangles in mesh and so is proportional to original mesh size. Note the actual reduction may be less depending on triangulation and topological constraints. For further details see VTK vtkQuadricDecimation documentation."
          },
          "smoothing_iterations": {
            "default": 1,
            "title": "Smoothing Iterations",
            "type": "integer",
            "description": " Mesh smoothing parameter. The number of iterations that mesh smoothing and decimation is run. If smoothing_iterations > 1, the decimated result is used as input for subsequent smoothing rounds. Recommended to start with 1 iteration and increase if resulting smoothing is insufficient. For each iteration after the first, the passband is reduced and feature_angle is increased incrementally to enhance smoothing. Specifically, the passband is reduced by factor 1/(2^n), and the feature_angle is increased by an increment of (5 * n), where n = iteration round (n=0 is the first iteration). The target_reduction is fixed to 0.1 smoothing_iterations > 1. For example if user inputs (0.01, 160, 0.98) for (passband, feature_angle, target_reduction), the second iteration will use parameters (0.005, 165, 0.1), the third (0.0025, 170, 0.1), etc. Maximum feature_angle is capped at 180. Note that additional iterations usually do not significantly add to processing time as the number of mesh verteces is typically significantly reduced after the first decimation iteration."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "SurfaceMeshMultiscale"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Segment by Intensity Threshold",
      "category": "Segmentation",
      "modality": "HCS",
      "tags": [
        "Classical segmentation",
        "3D"
      ],
      "docs_info": "### Purpose\n- Performs **full 3D object segmentation** of raw intensity images using intensity thresholding.\n- Combines two intensity channels, applies **Gaussian smoothing** and **Canny edge detection** for refined masks.\n- Filters out debris and neighboring objects by selecting the **largest connected component** within a masked region.\n- Outputs a new 3D segmentation label image and an updated masking ROI table.\n\n### Outputs\n- A **new 3D label image** stored in the dataset, with refined object segmentation.\n- A corresponding **bounding-box ROI table** saved as `{output_label_name}_ROI_table`.\n\n### Limitations\n- Requires pre-segmented 2D MIP-based ROI regions as input for masking.\n- Supports intensity thresholding with either **Otsu's method** or a user-defined threshold.\n- Assumes consistent image resolution and pixel intensities across channels.\n- Regions with extreme intensity variations or overlapping objects may require manual parameter tuning for optimal results.\n",
      "executable_non_parallel": "fractal/init_select_many_rounds.py",
      "executable_parallel": "fractal/segment_by_intensity_threshold.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "select_acquisitions": {
            "items": {
              "type": "integer"
            },
            "title": "Select Acquisitions",
            "type": "array",
            "description": "List of rounds to which correction should be applied, list of integers."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "select_acquisitions"
        ],
        "type": "object",
        "title": "InitSelectManyRounds"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "title": "Init Args",
            "type": "object",
            "description": "Init arguments for Fractal server."
          },
          "label_name": {
            "default": "org",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation (usually based on 2D MIP) that identifies objects in image."
          },
          "roi_table": {
            "default": "org_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to label_name. This table is used to iterate over objects and load object regions."
          },
          "output_label_name": {
            "default": "org3d",
            "title": "Output Label Name",
            "type": "string",
            "description": "Desired name for new output label. The corresponding ROI table will be saved as {output_label_name}_ROI_table."
          },
          "channel_1": {
            "$ref": "#/$defs/ChannelInputModel",
            "title": "Channel 1",
            "description": "Channel of raw image used for thresholding. Requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`)."
          },
          "background_channel_1": {
            "default": 800,
            "title": "Background Channel 1",
            "type": "integer",
            "description": "Pixel intensity value of background to subtract from channel 1 raw image."
          },
          "maximum_channel_1": {
            "title": "Maximum Channel 1",
            "type": "integer",
            "description": "Maximum pixel intensity value that channel 1 image is rescaled to."
          },
          "weight_channel_1": {
            "default": 0.5,
            "title": "Weight Channel 1",
            "type": "number",
            "description": "Float specifying weight of channel 1 image. Channels are combined as (weight_channel_1 * ch1_raw) + (weight_channel_2 * ch2_raw). When both weights are 0.5, channels are averaged. If no second channel is provided, this parameter is ignored."
          },
          "combine_with_channel_2": {
            "default": false,
            "title": "Combine With Channel 2",
            "type": "boolean",
            "description": "if True, a second channel can be added. The Channel 1 and 2 images are combined using weights specified with weight_channel_1 and weight_channel_2, and thresholding is performed using this combined image."
          },
          "channel_2": {
            "allOf": [
              {
                "$ref": "#/$defs/ChannelInputModel"
              }
            ],
            "title": "Channel 2",
            "description": "Channel of second raw image to be combined with channel 1 image. Requires either `wavelength_id` (e.g. `A02_C02`) or `label` (e.g. `BCAT`)."
          },
          "background_channel_2": {
            "title": "Background Channel 2",
            "type": "integer",
            "description": "Pixel intensity value of background to subtract from channel 2 raw image."
          },
          "maximum_channel_2": {
            "title": "Maximum Channel 2",
            "type": "integer",
            "description": "Maximum pixel intensity value that channel 1 image is rescaled to."
          },
          "weight_channel_2": {
            "default": 0.5,
            "title": "Weight Channel 2",
            "type": "number",
            "description": "Float specifying weight of channel 2 image. Channels are combined as (weight_channel_1 * ch1_raw) + (weight_channel_2 * ch2_raw)"
          },
          "otsu_threshold": {
            "default": true,
            "title": "Otsu Threshold",
            "type": "boolean",
            "description": "if True, the threshold for each region is calculated with the Otsu method. This threshold method is more robust to intensity variation between objects compared to intensity_threshold."
          },
          "otsu_weight": {
            "default": 1.0,
            "title": "Otsu Weight",
            "type": "number",
            "description": "Scale calculated Otsu threhsold by this value. Values lower than 1 (e.g. 0.9) reduce Otsu threshold (e.g. by 10 %) to include lower-intensity pixels in thresholding."
          },
          "intensity_threshold": {
            "default": -1,
            "title": "Intensity Threshold",
            "type": "integer",
            "description": "Integer that specifies threshold intensity value to binarize image. Must be supplied if Otsu thresholding is not used. Intensities below this value will be set to 0, intensities above are set to 1. The specified value should correspond to intensity range of raw image (e.g. for 16-bit images, 0-65535). Recommended threshold value is above image background level and below dimmest regions of image, particularly at deeper z-depth."
          },
          "gaussian_sigma_raw_image": {
            "default": 30,
            "title": "Gaussian Sigma Raw Image",
            "type": "number",
            "description": "Float that specifies sigma (standard deviation, in pixels) for 3D Gaussian kernel used for blurring of raw intensity image prior to thresholding and edge detection. Higher values correspond to more blurring that reduce holes in thresholded image. Recommended range 10-40."
          },
          "gaussian_sigma_threshold_image": {
            "default": 20,
            "title": "Gaussian Sigma Threshold Image",
            "type": "number",
            "description": "Float that specifies sigma (standard deviation, in pixels) for 2D Gaussian kernel used for blurring each z-slice of thresholded binary image prior to edge detection. Higher values correspond to more blurring and smoother surface edges. Recommended range 10-30."
          },
          "small_objects_diameter": {
            "default": 30,
            "title": "Small Objects Diameter",
            "type": "number",
            "description": "Float that specifies the approximate diameter, in pixels and at level=0, of debris in the image. This value is used to filter out small objects using skimage.morphology.remove_small_objects."
          },
          "expand_by_pixels": {
            "default": 20,
            "title": "Expand By Pixels",
            "type": "integer",
            "description": "Expand initial threshold mask by this number of pixels and fill holes. Mask is subsequently dilated and returned to original size. This step serves to fill holes in dim regions. Higher values lead to more holes filled, but neighboring objects or debris may become fused."
          },
          "contour_value_outer": {
            "default": 0.8,
            "title": "Contour Value Outer",
            "type": "number",
            "description": "Float in range [0,1]. This is the value used to draw contour line around object. Higher values result in tighter fit of edge mask to intensity image."
          },
          "linear_z_illumination_correction": {
            "default": false,
            "title": "Linear Z Illumination Correction",
            "type": "boolean",
            "description": "Set to True if linear z illumination correction is desired. Iterate over z-slices to apply correction."
          },
          "start_z_slice": {
            "default": 40,
            "title": "Start Z Slice",
            "type": "integer",
            "description": "Z-slice number at which to begin to apply linear correction, e.g. slice 40 if image stack has 100 slices."
          },
          "m_slope": {
            "default": 0.015,
            "title": "M Slope",
            "type": "number",
            "description": "Slope factor of illumination correction. Higher values have more extreme correction. This value sets the multiplier for a given z-slice by formula m_slope * (i - start_z_slice) + 1, where i is the current z-slice in iterator."
          },
          "segment_lumen": {
            "default": false,
            "title": "Segment Lumen",
            "type": "boolean",
            "description": "if True, lumen (assumed to be negative space in object) will also be segmented. In this case, three label maps are output: outer contour (epithelial surface) with holes filled, inner contour (lumen), and the epithelial mask (difference between outer and inner regions)."
          },
          "contour_value_inner": {
            "default": 0.8,
            "title": "Contour Value Inner",
            "type": "number",
            "description": "Float in range [0,1]. This is the value used to draw contour line around lumen of object. Higher values result in tighter fit of edge mask to intensity image."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "channel_1",
          "maximum_channel_1"
        ],
        "type": "object",
        "title": "SegmentByIntensityThreshold"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Spherical Harmonics from Label Image",
      "category": "Measurement",
      "modality": "HCS",
      "tags": [
        "3D"
      ],
      "docs_info": "### Purpose\n- Computes **spherical harmonics** for 3D segmented objects in a label image using the **aics_shparam** library.\n- Calculates and analyzes the **shape features** of objects, including reconstruction error.\n- Outputs spherical harmonic coefficients and optionally saves reconstructed surface meshes.\n\n### Outputs\n- A **feature table** containing spherical harmonic coefficients and reconstruction error (**MSE**) per object.\n- Optionally, the **computed surface mesh** and the **reconstructed mesh** (from harmonics), saved as `.stl` files in a new `meshes` folder.\n\n### Limitations\n- Input label image must contain 3D segmented objects; neighboring objects are removed by masking.\n- The accuracy of spherical harmonics depends on the chosen **maximum degree (`lmax`)** and input label quality.\n- Mesh reconstruction might smooth out fine details in highly complex shapes.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/spherical_harmonics_from_labelimage.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "default": "org_3d",
            "title": "Label Name",
            "type": "string",
            "description": "Label for which spherical harmonics are calculated"
          },
          "roi_table": {
            "default": "org_ROI_table_3d",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. e.g. consensus object table 'org_ROI_table_consensus'"
          },
          "lmax": {
            "default": 2,
            "title": "Lmax",
            "type": "integer",
            "description": "Maximum degree of the spherical harmonics coefficients"
          },
          "save_mesh": {
            "default": true,
            "title": "Save Mesh",
            "type": "boolean",
            "description": "If True, saves the computed surface mesh (with vtkContourFilter in aics_shparam functions) on disk in subfolder 'meshes'. Filename corresponds to object label id"
          },
          "save_reconstructed_mesh": {
            "default": true,
            "title": "Save Reconstructed Mesh",
            "type": "boolean",
            "description": "If true, reconstruct mesh from spherical harmonics and save as stl in meshes zarr directory. Filename corresponds to object label id"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "SphericalHarmonicsFromLabelimage"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Mesh Measurements",
      "category": "Measurement",
      "modality": "HCS",
      "tags": [
        "3D",
        "mesh",
        "morphology"
      ],
      "docs_info": "### Purpose\n- Extracts detailed **shape features** from 3D meshes, including volume, surface area, solidity, concavity, and aspect ratio.\n- Optionally calculates **Gaussian curvature** for mesh surfaces and **spherical harmonics** to decompose mesh geometry.\n- Outputs feature tables, curvature meshes, and optional harmonic-reconstructed meshes.\n\n### Outputs\n1. A **feature table** with extracted mesh measurements, including:\n   - Volume, surface area, aspect ratio, concavity, normalized surface area-to-volume ratio, and more.\n2. Optional **spherical harmonic coefficients** and reconstruction error (MSE), saved as a separate table.\n3. Optional **reconstructed meshes** from spherical harmonics saved as `.stl`.\n4. Optional **Gaussian curvature meshes** saved as `.vtp` files in a new `curvature` folder.\n5. Optional **convex hull** and **bounding box** meshes saved as `.vtp` files.\n\n### Limitations\n- Requires pre-existing **.stl meshes** within the Zarr structure (e.g., generated by the **Surface Mesh Multiscale** task).\n- Mesh files must match the **object labels** specified in the ROI table.\n- Computational cost increases when enabling **Gaussian curvature** or **spherical harmonics** calculations.\n- Mesh quality and accuracy depend on the input segmentation and mesh generation parameters.\n",
      "executable_non_parallel": "fractal/_init_group_by_well_for_multiplexing.py",
      "executable_parallel": "fractal/scmultiplex_mesh_measurements.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitGroupByWellForMultiplexing"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference acquisition. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Initialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference acquisition that are being processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "mesh_name": {
            "title": "Mesh Name",
            "type": "string",
            "description": "Mesh folder name for which features are to be extracted. Must contain .stl format meshes whose filename corresponds to label name in ROI table."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to labels of meshed objects, only used for indexing objects"
          },
          "output_table_name": {
            "title": "Output Table Name",
            "type": "string",
            "description": "Name of the output AnnData table to save the measurements in. A table of this name can't exist yet in the OME-Zarr file"
          },
          "save_hulls": {
            "default": true,
            "title": "Save Hulls",
            "type": "boolean",
            "description": "if True, save the calculated convex hull and bounding box as .vtp meshes within meshes/[mesh_name]_convex_hull and meshes/[mesh_name]_bounding_box directories"
          },
          "calculate_curvature": {
            "default": true,
            "title": "Calculate Curvature",
            "type": "boolean",
            "description": "if True, calculate Gaussian curvature at each mesh point and save as .vtp mesh on disk within meshes/[mesh_name]_curvature folder in zarr structure. Filename corresponds to object label id."
          },
          "calculate_harmonics": {
            "default": true,
            "title": "Calculate Harmonics",
            "type": "boolean",
            "description": "if True, calculate spherical harmonics of mesh using aics_shparam"
          },
          "lmax": {
            "default": 2,
            "title": "Lmax",
            "type": "integer",
            "description": "Maximum degree of the spherical harmonics coefficients"
          },
          "translate_to_origin": {
            "default": true,
            "title": "Translate To Origin",
            "type": "boolean",
            "description": "If true, translate centroid of mesh to origin prior to spherical harmonic decomposition. Recommended set to True"
          },
          "save_reconstructed_mesh": {
            "default": true,
            "title": "Save Reconstructed Mesh",
            "type": "boolean",
            "description": "If true, reconstruct mesh from spherical harmonics and save as stl in meshes zarr directory"
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "mesh_name",
          "roi_table",
          "output_table_name"
        ],
        "type": "object",
        "title": "ScmultiplexMeshMeasurements"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Feature Measurements",
      "category": "Measurement",
      "tags": [
        "regionprops",
        "morphology",
        "intensity"
      ],
      "docs_info": "### Purpose\n- **Measures intensity and morphology features** from existing segmentation images in an OME-Zarr dataset.\n- Computes advanced 3D morphology metrics, including surface area, using extended `regionprops` measurements.\n- Supports both intensity-based and morphology-only measurements:\n   - If no input intensity channels are provided, the task calculates morphology features only.\n   - For intensity measurements, channels can be specified individually, allowing flexibility across different image inputs.\n- Enables **measurements within masked objects** (e.g., measuring nuclei properties within organoids) by specifying an `input_ROI_table` that defines parent regions, such as organoid ROIs.\n\n### Limitations\n- Currently tested only on image data in the **CZYX** format.\n- Measurement accuracy and performance may depend on the spacing and resolution of input images.\n- Does not support measurements at lower resolutions (e.g., beyond level 0).\n",
      "executable_parallel": "fractal/scmultiplex_feature_measurements.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_image": {
            "title": "Label Image",
            "type": "string",
            "description": "Name of the label image to use for measurements. Needs to exist in OME-Zarr file"
          },
          "output_table_name": {
            "title": "Output Table Name",
            "type": "string",
            "description": "Name of the output AnnData table to save the measurements in. A table of this name can't exist yet in the OME-Zarr file"
          },
          "input_channels": {
            "additionalProperties": {
              "$ref": "#/$defs/ChannelInputModel"
            },
            "title": "Input Channels",
            "type": "object",
            "description": "Dictionary of channels to measure. Keys are the names that will be added as prefixes to the measurements, values are another dictionary containing either wavelength_id or channel_label information to allow Fractal to find the correct channel (but not both). Example: {\"C01\": {\"wavelength_id\": \"A01_C01\"}. To only measure morphology, provide an empty dict"
          },
          "input_ROI_table": {
            "default": "well_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table to loop over. Needs to exists as a ROI table in the OME-Zarr file"
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Resolution of the intensity image to load for measurements. Only tested for level 0"
          },
          "label_level": {
            "default": 0,
            "title": "Label Level",
            "type": "integer",
            "description": "Resolution of the label image to load for measurements."
          },
          "measure_morphology": {
            "default": true,
            "title": "Measure Morphology",
            "type": "boolean",
            "description": "Set to True to measure morphology features"
          },
          "allow_duplicate_labels": {
            "default": false,
            "title": "Allow Duplicate Labels",
            "type": "boolean",
            "description": "Set to True to allow saving measurement tables with non-unique label values. Can happen when segmentation is run on a different ROI than the measurements (e.g. segment per well, but measure per FOV)"
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_url",
          "label_image",
          "output_table_name"
        ],
        "type": "object",
        "title": "ScmultiplexFeatureMeasurements"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Expand Labels",
      "category": "Image Processing",
      "tags": [
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Expands segmented **labels** in 2D or 3D images **without overlap**.\n- Supports expansion by a fixed pixel distance or dynamically based on **label size**.\n- Optionally masks expanded labels using **parent objects** to prevent spillover.\n- Outputs an expanded label image and preserves non-overlapping object boundaries.\n\n### Outputs\n- A new **expanded label image** saved with an `_expanded` suffix.\n\n### Limitations\n- If masking by parent is enabled, the parent object label image must be provided.\n- Expansion beyond object boundaries may be clipped, depending on the surrounding labels and image dimensions.\n",
      "executable_non_parallel": "fractal/init_select_many_rounds.py",
      "executable_parallel": "fractal/expand_labels.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "select_acquisitions": {
            "items": {
              "type": "integer"
            },
            "title": "Select Acquisitions",
            "type": "array",
            "description": "List of rounds to which correction should be applied, list of integers."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "select_acquisitions"
        ],
        "type": "object",
        "title": "InitSelectManyRounds"
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed."
          },
          "init_args": {
            "title": "Init Args",
            "type": "object",
            "description": "Init arguments for Fractal server."
          },
          "label_name_to_expand": {
            "default": "nuc",
            "title": "Label Name To Expand",
            "type": "string",
            "description": "Label name of segmentation to be expanded."
          },
          "roi_table": {
            "default": "org_ROI_table_linked",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table used to iterate over objects and load object regions. If a table of type \"roi_table\" is passed, e.g. well_ROI_table, all objects for each region in the table will be loaded and expanded simultaneously. If a table of type \"masking_roi_table\" is passed, e.g. a segmentation ROI table, the task iterates over these objects and loads only the children (i.e. label_name_to_expand) that belong to the parent object."
          },
          "masking_label_map": {
            "title": "Masking Label Map",
            "type": "string",
            "description": "Label name of segmented objects that are parents of label_name. This input is mandatory if a roi table of type \"masking_roi_table\" is provided. It is the name of the label map that corresponds to the input ROI table. The masking_label_map will be used to mask label_name_to_expand objects, to only select children belonging to given parent."
          },
          "mask_output": {
            "default": true,
            "title": "Mask Output",
            "type": "boolean",
            "description": "If True, expanded label is masked by parent label. Only used if masking_label_map is provided. Recommended to set as True, to avoid overwriting of children labels between neighboring parents. However, it may lead to expanded results to be cropped by parent mask; in this case, the parent mask can first be expanded."
          },
          "expand_by_pixels": {
            "title": "Expand By Pixels",
            "type": "integer",
            "description": "Default expansion parameter. Integer value for pixel distance to expand by."
          },
          "calculate_image_based_expansion_distance": {
            "default": false,
            "title": "Calculate Image Based Expansion Distance",
            "type": "boolean",
            "description": "If true, overrides any set expand_by_pixels value, and expansion distance is calculated based on the average label size in loaded region. In this case, expandby_factor must be supplied."
          },
          "expand_by_factor": {
            "title": "Expand By Factor",
            "type": "number",
            "description": "Only used if calculate_image_based_expansion_distance is True. Multiplier that specifies pixels by which to expand each label. Float in range [0, 1 or higher], e.g. 0.2 means that 20% of mean equivalent diameter of labels in region is used."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "ExpandLabels"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Calculate Z-Illumination Correction",
      "input_types": {
        "z_illum_corrected": false,
        "is_3D": true
      },
      "category": "Image Processing",
      "modality": "HCS",
      "tags": [
        "3D",
        "illumination correction"
      ],
      "docs_info": "### Purpose\n- Apply z-illumination correction per object in 3D image.\n- Task takes as input user-defined channels and z-illumination correction tables,\n    and applies correction to the channel images. The channel of the table is matched to the channel of the\n    input image based on wavelength id or label. For multiplexing experiments, the user can specify which round(s) and\n    channel(s) the z-illumination correction should be applied to.\n- The z-illumination correction is applied per object, as different objects can have different z-illumination\n    profiles. The object segmentation image is provided with \"label_name\" and corresponding \"roi_table\" task inputs.\n    The label IDs of these objects must match the ID's that z-illumination calculation was run on (e.g. by running\n    Calculate Object Linking).\n- Processing proceeds as follows, with chunk-wise parallelization by Dask:\n- (1) The input correction table (anndata) is used to generate a 3D correction array that matches the size and\n    chunking of the label image. The correction array values are initialized to 1, and for regions where a segmented\n    object exists, 1 is replaced with the value of the z-correction table for the object and z-position. If the\n    correction table has been generated by the Calculate Z-Illumination Correction task, values of array are 0 to 1;\n    values closer to 0 will have a stronger correction.\n- (2) Background (user-specified per input channel) is subtracted from the channel image prior to correction. Task\n    assumes that background is not object-dependent.\n- (3) The channel image is divided element-wise by the correction array.\n- (4) Background is added back.\n\n### Outputs\n- Output is the input zarr image array, with channels selected for correction replaced with the corrected version.\n    Channels in zarr that were not selected but still present in zarr remain unmodified. The output zarr has data\n    type \"z_illum_corrected\", even if some channels remain uncorrected.\n- The user has option to overwrite input (=True), in which case the uncorrected zarr is deleted and replaced with\n    the corrected zarr. If False, a new zarr is generated (warning - this causes data duplication) with the\n    specified suffix added, output_group_suffix.\n",
      "executable_non_parallel": "fractal/init_select_multiplexing_round.py",
      "executable_parallel": "fractal/calculate_z_illumination_correction.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "selected_acquisition": {
            "default": 0,
            "title": "Selected Acquisition",
            "type": "integer",
            "description": "Which multiplexing round to select for processing. Uses the OME-NGFF HCS well metadata acquisition keys to find the round."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitSelectMultiplexingRound"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string",
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`. Can only be specified if label is not set."
              },
              "label": {
                "title": "Label",
                "type": "string",
                "description": "Name of the channel. Can only be specified if wavelength_id is not set."
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. This should be the image or multiplexing round that contains the uniform staining to be used for illumination correction."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistrationConsensus",
            "title": "Init Args",
            "description": "Initialization arguments provided by`init_select_multiplexing_round`."
          },
          "input_channels": {
            "items": {
              "$ref": "#/$defs/ChannelInputModel"
            },
            "title": "Input Channels",
            "type": "array",
            "description": "list of ChannelInputModel objects, where the user specifies the channels for calculating correction (with wavelength id or label), within the round selected in the init task."
          },
          "label_name": {
            "default": "org",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of the 3D segmentation that identifies objects in image."
          },
          "roi_table": {
            "default": "org_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to label_name."
          },
          "percentile": {
            "default": 90,
            "title": "Percentile",
            "type": "integer",
            "description": "Integer value of percentile used to calculate intensity value of each z-slice. Recommended range is 80-90. Higher values (e.g. 99) are more sensitive to individual high-intensity in image, making the intensity vs. z curve less smooth. Lower values may pick up intensity of background or empty space in the image."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "input_channels"
        ],
        "type": "object",
        "title": "CalculateZIlluminationCorrection"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Apply Z-Illumination Correction",
      "input_types": {
        "z_illum_corrected": false,
        "is_3D": true
      },
      "output_types": {
        "z_illum_corrected": true,
        "is_3D": true
      },
      "category": "Image Processing",
      "modality": "HCS",
      "tags": [
        "3D",
        "illumination correction"
      ],
      "docs_info": "### Purpose\n- Apply z-illumination correction per object in 3D image.\n- Task takes as input user-defined channels and z-illumination correction tables,\n    and applies correction to the channel images. The channel of the table is matched to the channel of the\n    input image based on wavelength id or label. For multiplexing experiments, the user can specify which round(s) and\n    channel(s) the z-illumination correction should be applied to.\n- The z-illumination correction is applied per object, as different objects can have different z-illumination\n    profiles. The object segmentation image is provided with \"label_name\" and corresponding \"roi_table\" task inputs.\n    The label IDs of these objects must match the ID's that z-illumination calculation was run on (e.g. by running\n    Calculate Object Linking).\n- Processing proceeds as follows, with chunk-wise parallelization by Dask:\n- (1) The input correction table (anndata) is used to generate a 3D correction array that matches the size and\n    chunking of the label image. The correction array values are initialized to 1, and for regions where a segmented\n    object exists, 1 is replaced with the value of the z-correction table for the object and z-position. If the\n    correction table has been generated by the Calculate Z-Illumination Correction task, values of array are 0 to 1;\n    values closer to 0 will have a stronger correction.\n- (2) Background (user-specified per input channel) is subtracted from the channel image prior to correction. Task\n    assumes that background is not object-dependent.\n- (3) The channel image is divided element-wise by the correction array.\n- (4) Background is added back.\n\n### Outputs\n- Output is the input zarr image array, with channels selected for correction replaced with the corrected version.\n    Channels in zarr that were not selected but still present in zarr remain unmodified. The output zarr has data\n    type \"z_illum_corrected\", even if some channels remain uncorrected.\n- The user has option to overwrite input (=True), in which case the uncorrected zarr is deleted and replaced with\n    the corrected zarr. If False, a new zarr is generated (warning - this causes data duplication) with the\n    specified suffix added, output_group_suffix.\n",
      "executable_non_parallel": "fractal/init_select_illumination_round.py",
      "executable_parallel": "fractal/apply_z_illumination_correction.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "illumination_correction_acquisition": {
            "default": 0,
            "title": "Illumination Correction Acquisition",
            "type": "integer",
            "description": "Which round was used for calculating illumination tables. Uses the OME-NGFF HCS well metadata acquisition keys to find the round."
          },
          "apply_correction_to_acquisitions": {
            "items": {
              "type": "integer"
            },
            "title": "Apply Correction To Acquisitions",
            "type": "array",
            "description": "List of rounds to which correction should be applied."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "apply_correction_to_acquisitions"
        ],
        "type": "object",
        "title": "InitSelectIlluminationRound"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsIllumination": {
            "description": "Registration init args.",
            "properties": {
              "correction_zarr_url": {
                "title": "Correction Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "correction_zarr_url"
            ],
            "title": "InitArgsIllumination",
            "type": "object"
          },
          "ZIlluminationChannelInputModel": {
            "description": "Extended version of ChannelInputModel with an additional attribute.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "z_correction_table": {
                "title": "Z Correction Table",
                "type": "string"
              },
              "background_intensity": {
                "default": 0,
                "title": "Background Intensity",
                "type": "integer"
              }
            },
            "title": "ZIlluminationChannelInputModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsIllumination",
            "title": "Init Args",
            "description": "Initialization arguments provided by `init_select_illumination_round`. It contains the zarr-url to the z-illumination correction round."
          },
          "input_channels": {
            "items": {
              "$ref": "#/$defs/ZIlluminationChannelInputModel"
            },
            "title": "Input Channels",
            "type": "array",
            "description": "list of ZIlluminationChannelInputModel objects, where the user specifies the channels for applying correction (with wavelength id or label), the corresponding name for the z-correction table, and the background for this channel. This setting will be applied to all rounds selected in the init task. If different values per round are desired, run separate instances of this task in the workflow."
          },
          "label_name": {
            "default": "org",
            "title": "Label Name",
            "type": "string",
            "description": "Label name of segmentation (usually based on 2D MIP, converted to 3D) that identifies objects in image."
          },
          "roi_table": {
            "default": "org_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table that corresponds to label_name."
          },
          "overwrite_input": {
            "default": false,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Boolean, if True overwrites the original, uncorrected image with the output of this task."
          },
          "output_group_suffix": {
            "default": "zillum",
            "title": "Output Group Suffix",
            "type": "string",
            "description": "If overwrite_input=False, this suffix is added to the new OME-Zarr image that contains the z-illumination corrected images."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "input_channels"
        ],
        "type": "object",
        "title": "ApplyZIlluminationCorrection"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    },
    {
      "name": "scMultiplex Fuse Touching Labels",
      "category": "Image Processing",
      "tags": [
        "2D"
      ],
      "docs_info": "### Purpose\n- Fuse touching labels in segmentation images, in 2D or 3D. Connected components are identified during labeling\n    based on the connectivity argument. For a more detailed explanation of 1- or 2- connectivity, see documentation\n    of skimage.measure.label() function. When set to None (default), full connectivity (ndim of input array) is used.\n\n- Input is segmentation image with 0 value for background. Anything above 0 is assumed to be a labeled object.\n    Touching labels are labeled in numerically increasing order starting from 1 to n, where n is the number of\n    connected components (objects) identified.\n\n- This task has been tested for fusion of 2D MIP segmentation. Since fusion must occur on the full well numpy\n    array loaded into memory, performance may be poor for large 3D arrays.\n\n### Outputs\n- The fused label image is saved as a new label in zarr, with name {label_name_to_fuse}_fused.\n- The new ROI table for the fused label image is saved as a masking ROI table, with name\n    {label_name_to_fuse}_fused_ROI_table.\n",
      "executable_non_parallel": "fractal/init_select_many_rounds.py",
      "executable_parallel": "fractal/fuse_touching_labels.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "select_acquisitions": {
            "items": {
              "type": "integer"
            },
            "title": "Select Acquisitions",
            "type": "array",
            "description": "List of rounds to which correction should be applied, list of integers."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "select_acquisitions"
        ],
        "type": "object",
        "title": "InitSelectManyRounds"
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Missing description"
          },
          "init_args": {
            "title": "Init Args",
            "type": "object",
            "description": "Missing description"
          },
          "label_name_to_fuse": {
            "default": "org",
            "title": "Label Name To Fuse",
            "type": "string",
            "description": "Missing description"
          },
          "connectivity": {
            "title": "Connectivity",
            "type": "integer",
            "description": "Missing description"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "FuseTouchingLabels"
      },
      "docs_link": "https://github.com/fmi-basel/gliberal-scMultipleX"
    }
  ],
  "has_args_schemas": true,
  "args_schema_version": "pydantic_v2",
  "authors": "Nicole Repina, Enrico Tagliavini, Tim-Oliver Buchholz, Joel Luethi"
}
